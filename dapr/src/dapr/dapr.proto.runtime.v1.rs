// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JobEventRequest {
    /// Job name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Job data to be sent back to app.
    #[prost(message, optional, tag = "2")]
    pub data: ::core::option::Option<::prost_types::Any>,
    /// Required. method is a method name which will be invoked by caller.
    #[prost(string, tag = "3")]
    pub method: ::prost::alloc::string::String,
    /// The type of data content.
    ///
    /// This field is required if data delivers http request body
    /// Otherwise, this is optional.
    #[prost(string, tag = "4")]
    pub content_type: ::prost::alloc::string::String,
    /// HTTP specific fields if request conveys http-compatible request.
    ///
    /// This field is required for http-compatible request. Otherwise,
    /// this field is optional.
    #[prost(message, optional, tag = "5")]
    pub http_extension: ::core::option::Option<super::super::common::v1::HttpExtension>,
}
/// JobEventResponse is the response from the app when a job is triggered.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct JobEventResponse {}
/// TopicEventRequest message is compatible with CloudEvent spec v1.0
/// <https://github.com/cloudevents/spec/blob/v1.0/spec.md>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TopicEventRequest {
    /// id identifies the event. Producers MUST ensure that source + id
    /// is unique for each distinct event. If a duplicate event is re-sent
    /// (e.g. due to a network error) it MAY have the same id.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// source identifies the context in which an event happened.
    /// Often this will include information such as the type of the
    /// event source, the organization publishing the event or the process
    /// that produced the event. The exact syntax and semantics behind
    /// the data encoded in the URI is defined by the event producer.
    #[prost(string, tag = "2")]
    pub source: ::prost::alloc::string::String,
    /// The type of event related to the originating occurrence.
    #[prost(string, tag = "3")]
    pub r#type: ::prost::alloc::string::String,
    /// The version of the CloudEvents specification.
    #[prost(string, tag = "4")]
    pub spec_version: ::prost::alloc::string::String,
    /// The content type of data value.
    #[prost(string, tag = "5")]
    pub data_content_type: ::prost::alloc::string::String,
    /// The content of the event.
    #[prost(bytes = "vec", tag = "7")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    /// The pubsub topic which publisher sent to.
    #[prost(string, tag = "6")]
    pub topic: ::prost::alloc::string::String,
    /// The name of the pubsub the publisher sent to.
    #[prost(string, tag = "8")]
    pub pubsub_name: ::prost::alloc::string::String,
    /// The matching path from TopicSubscription/routes (if specified) for this event.
    /// This value is used by OnTopicEvent to "switch" inside the handler.
    #[prost(string, tag = "9")]
    pub path: ::prost::alloc::string::String,
    /// The map of additional custom properties to be sent to the app. These are considered to be cloud event extensions.
    #[prost(message, optional, tag = "10")]
    pub extensions: ::core::option::Option<::prost_types::Struct>,
}
/// TopicEventResponse is response from app on published message
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TopicEventResponse {
    /// The list of output bindings.
    #[prost(enumeration = "topic_event_response::TopicEventResponseStatus", tag = "1")]
    pub status: i32,
}
/// Nested message and enum types in `TopicEventResponse`.
pub mod topic_event_response {
    /// TopicEventResponseStatus allows apps to have finer control over handling of the message.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TopicEventResponseStatus {
        /// SUCCESS is the default behavior: message is acknowledged and not retried or logged.
        Success = 0,
        /// RETRY status signals Dapr to retry the message as part of an expected scenario (no warning is logged).
        Retry = 1,
        /// DROP status signals Dapr to drop the message as part of an unexpected scenario (warning is logged).
        Drop = 2,
    }
    impl TopicEventResponseStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Success => "SUCCESS",
                Self::Retry => "RETRY",
                Self::Drop => "DROP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SUCCESS" => Some(Self::Success),
                "RETRY" => Some(Self::Retry),
                "DROP" => Some(Self::Drop),
                _ => None,
            }
        }
    }
}
/// TopicEventCERequest message is compatible with CloudEvent spec v1.0
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TopicEventCeRequest {
    /// The unique identifier of this cloud event.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// source identifies the context in which an event happened.
    #[prost(string, tag = "2")]
    pub source: ::prost::alloc::string::String,
    /// The type of event related to the originating occurrence.
    #[prost(string, tag = "3")]
    pub r#type: ::prost::alloc::string::String,
    /// The version of the CloudEvents specification.
    #[prost(string, tag = "4")]
    pub spec_version: ::prost::alloc::string::String,
    /// The content type of data value.
    #[prost(string, tag = "5")]
    pub data_content_type: ::prost::alloc::string::String,
    /// The content of the event.
    #[prost(bytes = "vec", tag = "6")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    /// Custom attributes which includes cloud event extensions.
    #[prost(message, optional, tag = "7")]
    pub extensions: ::core::option::Option<::prost_types::Struct>,
}
/// TopicEventBulkRequestEntry represents a single message inside a bulk request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TopicEventBulkRequestEntry {
    /// Unique identifier for the message.
    #[prost(string, tag = "1")]
    pub entry_id: ::prost::alloc::string::String,
    /// content type of the event contained.
    #[prost(string, tag = "4")]
    pub content_type: ::prost::alloc::string::String,
    /// The metadata associated with the event.
    #[prost(map = "string, string", tag = "5")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// The content of the event.
    #[prost(oneof = "topic_event_bulk_request_entry::Event", tags = "2, 3")]
    pub event: ::core::option::Option<topic_event_bulk_request_entry::Event>,
}
/// Nested message and enum types in `TopicEventBulkRequestEntry`.
pub mod topic_event_bulk_request_entry {
    /// The content of the event.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(bytes, tag = "2")]
        Bytes(::prost::alloc::vec::Vec<u8>),
        #[prost(message, tag = "3")]
        CloudEvent(super::TopicEventCeRequest),
    }
}
/// TopicEventBulkRequest represents request for bulk message
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TopicEventBulkRequest {
    /// Unique identifier for the bulk request.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// The list of items inside this bulk request.
    #[prost(message, repeated, tag = "2")]
    pub entries: ::prost::alloc::vec::Vec<TopicEventBulkRequestEntry>,
    /// The metadata associated with the this bulk request.
    #[prost(map = "string, string", tag = "3")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// The pubsub topic which publisher sent to.
    #[prost(string, tag = "4")]
    pub topic: ::prost::alloc::string::String,
    /// The name of the pubsub the publisher sent to.
    #[prost(string, tag = "5")]
    pub pubsub_name: ::prost::alloc::string::String,
    /// The type of event related to the originating occurrence.
    #[prost(string, tag = "6")]
    pub r#type: ::prost::alloc::string::String,
    /// The matching path from TopicSubscription/routes (if specified) for this event.
    /// This value is used by OnTopicEvent to "switch" inside the handler.
    #[prost(string, tag = "7")]
    pub path: ::prost::alloc::string::String,
}
/// TopicEventBulkResponseEntry Represents single response, as part of TopicEventBulkResponse, to be
/// sent by subscibed App for the corresponding single message during bulk subscribe
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TopicEventBulkResponseEntry {
    /// Unique identifier associated the message.
    #[prost(string, tag = "1")]
    pub entry_id: ::prost::alloc::string::String,
    /// The status of the response.
    #[prost(enumeration = "topic_event_response::TopicEventResponseStatus", tag = "2")]
    pub status: i32,
}
/// AppBulkResponse is response from app on published message
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TopicEventBulkResponse {
    /// The list of all responses for the bulk request.
    #[prost(message, repeated, tag = "1")]
    pub statuses: ::prost::alloc::vec::Vec<TopicEventBulkResponseEntry>,
}
/// BindingEventRequest represents input bindings event.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BindingEventRequest {
    /// Required. The name of the input binding component.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The payload that the input bindings sent
    #[prost(bytes = "vec", tag = "2")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    /// The metadata set by the input binging components.
    #[prost(map = "string, string", tag = "3")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// BindingEventResponse includes operations to save state or
/// send data to output bindings optionally.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BindingEventResponse {
    /// The name of state store where states are saved.
    #[prost(string, tag = "1")]
    pub store_name: ::prost::alloc::string::String,
    /// The state key values which will be stored in store_name.
    #[prost(message, repeated, tag = "2")]
    pub states: ::prost::alloc::vec::Vec<super::super::common::v1::StateItem>,
    /// The list of output bindings.
    #[prost(string, repeated, tag = "3")]
    pub to: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The content which will be sent to "to" output bindings.
    #[prost(bytes = "vec", tag = "4")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    /// The concurrency of output bindings to send data to
    /// "to" output bindings list. The default is SEQUENTIAL.
    #[prost(enumeration = "binding_event_response::BindingEventConcurrency", tag = "5")]
    pub concurrency: i32,
}
/// Nested message and enum types in `BindingEventResponse`.
pub mod binding_event_response {
    /// BindingEventConcurrency is the kind of concurrency
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BindingEventConcurrency {
        /// SEQUENTIAL sends data to output bindings specified in "to" sequentially.
        Sequential = 0,
        /// PARALLEL sends data to output bindings specified in "to" in parallel.
        Parallel = 1,
    }
    impl BindingEventConcurrency {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Sequential => "SEQUENTIAL",
                Self::Parallel => "PARALLEL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SEQUENTIAL" => Some(Self::Sequential),
                "PARALLEL" => Some(Self::Parallel),
                _ => None,
            }
        }
    }
}
/// ListTopicSubscriptionsResponse is the message including the list of the subscribing topics.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTopicSubscriptionsResponse {
    /// The list of topics.
    #[prost(message, repeated, tag = "1")]
    pub subscriptions: ::prost::alloc::vec::Vec<TopicSubscription>,
}
/// TopicSubscription represents topic and metadata.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TopicSubscription {
    /// Required. The name of the pubsub containing the topic below to subscribe to.
    #[prost(string, tag = "1")]
    pub pubsub_name: ::prost::alloc::string::String,
    /// Required. The name of topic which will be subscribed
    #[prost(string, tag = "2")]
    pub topic: ::prost::alloc::string::String,
    /// The optional properties used for this topic's subscription e.g. session id
    #[prost(map = "string, string", tag = "3")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// The optional routing rules to match against. In the gRPC interface, OnTopicEvent
    /// is still invoked but the matching path is sent in the TopicEventRequest.
    #[prost(message, optional, tag = "5")]
    pub routes: ::core::option::Option<TopicRoutes>,
    /// The optional dead letter queue for this topic to send events to.
    #[prost(string, tag = "6")]
    pub dead_letter_topic: ::prost::alloc::string::String,
    /// The optional bulk subscribe settings for this topic.
    #[prost(message, optional, tag = "7")]
    pub bulk_subscribe: ::core::option::Option<BulkSubscribeConfig>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TopicRoutes {
    /// The list of rules for this topic.
    #[prost(message, repeated, tag = "1")]
    pub rules: ::prost::alloc::vec::Vec<TopicRule>,
    /// The default path for this topic.
    #[prost(string, tag = "2")]
    pub default: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TopicRule {
    /// The optional CEL expression used to match the event.
    /// If the match is not specified, then the route is considered
    /// the default.
    #[prost(string, tag = "1")]
    pub r#match: ::prost::alloc::string::String,
    /// The path used to identify matches for this subscription.
    /// This value is passed in TopicEventRequest and used by OnTopicEvent to "switch"
    /// inside the handler.
    #[prost(string, tag = "2")]
    pub path: ::prost::alloc::string::String,
}
/// BulkSubscribeConfig is the message to pass settings for bulk subscribe
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BulkSubscribeConfig {
    /// Required. Flag to enable/disable bulk subscribe
    #[prost(bool, tag = "1")]
    pub enabled: bool,
    /// Optional. Max number of messages to be sent in a single bulk request
    #[prost(int32, tag = "2")]
    pub max_messages_count: i32,
    /// Optional. Max duration to wait for messages to be sent in a single bulk request
    #[prost(int32, tag = "3")]
    pub max_await_duration_ms: i32,
}
/// ListInputBindingsResponse is the message including the list of input bindings.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInputBindingsResponse {
    /// The list of input bindings.
    #[prost(string, repeated, tag = "1")]
    pub bindings: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// HealthCheckResponse is the message with the response to the health check.
/// This message is currently empty as used as placeholder.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HealthCheckResponse {}
/// Generated client implementations.
pub mod app_callback_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// AppCallback V1 allows user application to interact with Dapr runtime.
    /// User application needs to implement AppCallback service if it needs to
    /// receive message from dapr runtime.
    #[derive(Debug, Clone)]
    pub struct AppCallbackClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl AppCallbackClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> AppCallbackClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> AppCallbackClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            AppCallbackClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Invokes service method with InvokeRequest.
        pub async fn on_invoke(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::super::common::v1::InvokeRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::common::v1::InvokeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.AppCallback/OnInvoke",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("dapr.proto.runtime.v1.AppCallback", "OnInvoke"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all topics subscribed by this app.
        pub async fn list_topic_subscriptions(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::ListTopicSubscriptionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.AppCallback/ListTopicSubscriptions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "dapr.proto.runtime.v1.AppCallback",
                        "ListTopicSubscriptions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Subscribes events from Pubsub
        pub async fn on_topic_event(
            &mut self,
            request: impl tonic::IntoRequest<super::TopicEventRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TopicEventResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.AppCallback/OnTopicEvent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("dapr.proto.runtime.v1.AppCallback", "OnTopicEvent"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all input bindings subscribed by this app.
        pub async fn list_input_bindings(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::ListInputBindingsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.AppCallback/ListInputBindings",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "dapr.proto.runtime.v1.AppCallback",
                        "ListInputBindings",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Listens events from the input bindings
        ///
        /// User application can save the states or send the events to the output
        /// bindings optionally by returning BindingEventResponse.
        pub async fn on_binding_event(
            &mut self,
            request: impl tonic::IntoRequest<super::BindingEventRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BindingEventResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.AppCallback/OnBindingEvent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "dapr.proto.runtime.v1.AppCallback",
                        "OnBindingEvent",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod app_callback_health_check_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// AppCallbackHealthCheck V1 is an optional extension to AppCallback V1 to implement
    /// the HealthCheck method.
    #[derive(Debug, Clone)]
    pub struct AppCallbackHealthCheckClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl AppCallbackHealthCheckClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> AppCallbackHealthCheckClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> AppCallbackHealthCheckClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            AppCallbackHealthCheckClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Health check.
        pub async fn health_check(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::HealthCheckResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.AppCallbackHealthCheck/HealthCheck",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "dapr.proto.runtime.v1.AppCallbackHealthCheck",
                        "HealthCheck",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod app_callback_alpha_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// AppCallbackAlpha V1 is an optional extension to AppCallback V1 to opt
    /// for Alpha RPCs.
    #[derive(Debug, Clone)]
    pub struct AppCallbackAlphaClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl AppCallbackAlphaClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> AppCallbackAlphaClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> AppCallbackAlphaClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            AppCallbackAlphaClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Subscribes bulk events from Pubsub
        pub async fn on_bulk_topic_event_alpha1(
            &mut self,
            request: impl tonic::IntoRequest<super::TopicEventBulkRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TopicEventBulkResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.AppCallbackAlpha/OnBulkTopicEventAlpha1",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "dapr.proto.runtime.v1.AppCallbackAlpha",
                        "OnBulkTopicEventAlpha1",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sends job back to the app's endpoint at trigger time.
        pub async fn on_job_event_alpha1(
            &mut self,
            request: impl tonic::IntoRequest<super::JobEventRequest>,
        ) -> std::result::Result<
            tonic::Response<super::JobEventResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.AppCallbackAlpha/OnJobEventAlpha1",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "dapr.proto.runtime.v1.AppCallbackAlpha",
                        "OnJobEventAlpha1",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod app_callback_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with AppCallbackServer.
    #[async_trait]
    pub trait AppCallback: std::marker::Send + std::marker::Sync + 'static {
        /// Invokes service method with InvokeRequest.
        async fn on_invoke(
            &self,
            request: tonic::Request<super::super::super::common::v1::InvokeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::common::v1::InvokeResponse>,
            tonic::Status,
        >;
        /// Lists all topics subscribed by this app.
        async fn list_topic_subscriptions(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<
            tonic::Response<super::ListTopicSubscriptionsResponse>,
            tonic::Status,
        >;
        /// Subscribes events from Pubsub
        async fn on_topic_event(
            &self,
            request: tonic::Request<super::TopicEventRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TopicEventResponse>,
            tonic::Status,
        >;
        /// Lists all input bindings subscribed by this app.
        async fn list_input_bindings(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<
            tonic::Response<super::ListInputBindingsResponse>,
            tonic::Status,
        >;
        /// Listens events from the input bindings
        ///
        /// User application can save the states or send the events to the output
        /// bindings optionally by returning BindingEventResponse.
        async fn on_binding_event(
            &self,
            request: tonic::Request<super::BindingEventRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BindingEventResponse>,
            tonic::Status,
        >;
    }
    /// AppCallback V1 allows user application to interact with Dapr runtime.
    /// User application needs to implement AppCallback service if it needs to
    /// receive message from dapr runtime.
    #[derive(Debug)]
    pub struct AppCallbackServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> AppCallbackServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for AppCallbackServer<T>
    where
        T: AppCallback,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/dapr.proto.runtime.v1.AppCallback/OnInvoke" => {
                    #[allow(non_camel_case_types)]
                    struct OnInvokeSvc<T: AppCallback>(pub Arc<T>);
                    impl<
                        T: AppCallback,
                    > tonic::server::UnaryService<
                        super::super::super::common::v1::InvokeRequest,
                    > for OnInvokeSvc<T> {
                        type Response = super::super::super::common::v1::InvokeResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::super::super::common::v1::InvokeRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AppCallback>::on_invoke(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = OnInvokeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.AppCallback/ListTopicSubscriptions" => {
                    #[allow(non_camel_case_types)]
                    struct ListTopicSubscriptionsSvc<T: AppCallback>(pub Arc<T>);
                    impl<T: AppCallback> tonic::server::UnaryService<()>
                    for ListTopicSubscriptionsSvc<T> {
                        type Response = super::ListTopicSubscriptionsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AppCallback>::list_topic_subscriptions(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListTopicSubscriptionsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.AppCallback/OnTopicEvent" => {
                    #[allow(non_camel_case_types)]
                    struct OnTopicEventSvc<T: AppCallback>(pub Arc<T>);
                    impl<
                        T: AppCallback,
                    > tonic::server::UnaryService<super::TopicEventRequest>
                    for OnTopicEventSvc<T> {
                        type Response = super::TopicEventResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::TopicEventRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AppCallback>::on_topic_event(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = OnTopicEventSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.AppCallback/ListInputBindings" => {
                    #[allow(non_camel_case_types)]
                    struct ListInputBindingsSvc<T: AppCallback>(pub Arc<T>);
                    impl<T: AppCallback> tonic::server::UnaryService<()>
                    for ListInputBindingsSvc<T> {
                        type Response = super::ListInputBindingsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AppCallback>::list_input_bindings(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListInputBindingsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.AppCallback/OnBindingEvent" => {
                    #[allow(non_camel_case_types)]
                    struct OnBindingEventSvc<T: AppCallback>(pub Arc<T>);
                    impl<
                        T: AppCallback,
                    > tonic::server::UnaryService<super::BindingEventRequest>
                    for OnBindingEventSvc<T> {
                        type Response = super::BindingEventResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::BindingEventRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AppCallback>::on_binding_event(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = OnBindingEventSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for AppCallbackServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "dapr.proto.runtime.v1.AppCallback";
    impl<T> tonic::server::NamedService for AppCallbackServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Generated server implementations.
pub mod app_callback_health_check_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with AppCallbackHealthCheckServer.
    #[async_trait]
    pub trait AppCallbackHealthCheck: std::marker::Send + std::marker::Sync + 'static {
        /// Health check.
        async fn health_check(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<
            tonic::Response<super::HealthCheckResponse>,
            tonic::Status,
        >;
    }
    /// AppCallbackHealthCheck V1 is an optional extension to AppCallback V1 to implement
    /// the HealthCheck method.
    #[derive(Debug)]
    pub struct AppCallbackHealthCheckServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> AppCallbackHealthCheckServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for AppCallbackHealthCheckServer<T>
    where
        T: AppCallbackHealthCheck,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/dapr.proto.runtime.v1.AppCallbackHealthCheck/HealthCheck" => {
                    #[allow(non_camel_case_types)]
                    struct HealthCheckSvc<T: AppCallbackHealthCheck>(pub Arc<T>);
                    impl<T: AppCallbackHealthCheck> tonic::server::UnaryService<()>
                    for HealthCheckSvc<T> {
                        type Response = super::HealthCheckResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AppCallbackHealthCheck>::health_check(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = HealthCheckSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for AppCallbackHealthCheckServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "dapr.proto.runtime.v1.AppCallbackHealthCheck";
    impl<T> tonic::server::NamedService for AppCallbackHealthCheckServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Generated server implementations.
pub mod app_callback_alpha_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with AppCallbackAlphaServer.
    #[async_trait]
    pub trait AppCallbackAlpha: std::marker::Send + std::marker::Sync + 'static {
        /// Subscribes bulk events from Pubsub
        async fn on_bulk_topic_event_alpha1(
            &self,
            request: tonic::Request<super::TopicEventBulkRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TopicEventBulkResponse>,
            tonic::Status,
        >;
        /// Sends job back to the app's endpoint at trigger time.
        async fn on_job_event_alpha1(
            &self,
            request: tonic::Request<super::JobEventRequest>,
        ) -> std::result::Result<
            tonic::Response<super::JobEventResponse>,
            tonic::Status,
        >;
    }
    /// AppCallbackAlpha V1 is an optional extension to AppCallback V1 to opt
    /// for Alpha RPCs.
    #[derive(Debug)]
    pub struct AppCallbackAlphaServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> AppCallbackAlphaServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for AppCallbackAlphaServer<T>
    where
        T: AppCallbackAlpha,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/dapr.proto.runtime.v1.AppCallbackAlpha/OnBulkTopicEventAlpha1" => {
                    #[allow(non_camel_case_types)]
                    struct OnBulkTopicEventAlpha1Svc<T: AppCallbackAlpha>(pub Arc<T>);
                    impl<
                        T: AppCallbackAlpha,
                    > tonic::server::UnaryService<super::TopicEventBulkRequest>
                    for OnBulkTopicEventAlpha1Svc<T> {
                        type Response = super::TopicEventBulkResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::TopicEventBulkRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AppCallbackAlpha>::on_bulk_topic_event_alpha1(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = OnBulkTopicEventAlpha1Svc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.AppCallbackAlpha/OnJobEventAlpha1" => {
                    #[allow(non_camel_case_types)]
                    struct OnJobEventAlpha1Svc<T: AppCallbackAlpha>(pub Arc<T>);
                    impl<
                        T: AppCallbackAlpha,
                    > tonic::server::UnaryService<super::JobEventRequest>
                    for OnJobEventAlpha1Svc<T> {
                        type Response = super::JobEventResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::JobEventRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AppCallbackAlpha>::on_job_event_alpha1(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = OnJobEventAlpha1Svc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for AppCallbackAlphaServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "dapr.proto.runtime.v1.AppCallbackAlpha";
    impl<T> tonic::server::NamedService for AppCallbackAlphaServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// InvokeServiceRequest represents the request message for Service invocation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InvokeServiceRequest {
    /// Required. Callee's app id.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Required. message which will be delivered to callee.
    #[prost(message, optional, tag = "3")]
    pub message: ::core::option::Option<super::super::common::v1::InvokeRequest>,
}
/// GetStateRequest is the message to get key-value states from specific state store.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStateRequest {
    /// The name of state store.
    #[prost(string, tag = "1")]
    pub store_name: ::prost::alloc::string::String,
    /// The key of the desired state
    #[prost(string, tag = "2")]
    pub key: ::prost::alloc::string::String,
    /// The read consistency of the state store.
    #[prost(
        enumeration = "super::super::common::v1::state_options::StateConsistency",
        tag = "3"
    )]
    pub consistency: i32,
    /// The metadata which will be sent to state store components.
    #[prost(map = "string, string", tag = "4")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// GetBulkStateRequest is the message to get a list of key-value states from specific state store.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBulkStateRequest {
    /// The name of state store.
    #[prost(string, tag = "1")]
    pub store_name: ::prost::alloc::string::String,
    /// The keys to get.
    #[prost(string, repeated, tag = "2")]
    pub keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The number of parallel operations executed on the state store for a get operation.
    #[prost(int32, tag = "3")]
    pub parallelism: i32,
    /// The metadata which will be sent to state store components.
    #[prost(map = "string, string", tag = "4")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// GetBulkStateResponse is the response conveying the list of state values.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBulkStateResponse {
    /// The list of items containing the keys to get values for.
    #[prost(message, repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<BulkStateItem>,
}
/// BulkStateItem is the response item for a bulk get operation.
/// Return values include the item key, data and etag.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BulkStateItem {
    /// state item key
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    /// The byte array data
    #[prost(bytes = "vec", tag = "2")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    /// The entity tag which represents the specific version of data.
    /// ETag format is defined by the corresponding data store.
    #[prost(string, tag = "3")]
    pub etag: ::prost::alloc::string::String,
    /// The error that was returned from the state store in case of a failed get operation.
    #[prost(string, tag = "4")]
    pub error: ::prost::alloc::string::String,
    /// The metadata which will be sent to app.
    #[prost(map = "string, string", tag = "5")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// GetStateResponse is the response conveying the state value and etag.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStateResponse {
    /// The byte array data
    #[prost(bytes = "vec", tag = "1")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    /// The entity tag which represents the specific version of data.
    /// ETag format is defined by the corresponding data store.
    #[prost(string, tag = "2")]
    pub etag: ::prost::alloc::string::String,
    /// The metadata which will be sent to app.
    #[prost(map = "string, string", tag = "3")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// DeleteStateRequest is the message to delete key-value states in the specific state store.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteStateRequest {
    /// The name of state store.
    #[prost(string, tag = "1")]
    pub store_name: ::prost::alloc::string::String,
    /// The key of the desired state
    #[prost(string, tag = "2")]
    pub key: ::prost::alloc::string::String,
    /// The entity tag which represents the specific version of data.
    /// The exact ETag format is defined by the corresponding data store.
    #[prost(message, optional, tag = "3")]
    pub etag: ::core::option::Option<super::super::common::v1::Etag>,
    /// State operation options which includes concurrency/
    /// consistency/retry_policy.
    #[prost(message, optional, tag = "4")]
    pub options: ::core::option::Option<super::super::common::v1::StateOptions>,
    /// The metadata which will be sent to state store components.
    #[prost(map = "string, string", tag = "5")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// DeleteBulkStateRequest is the message to delete a list of key-value states from specific state store.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteBulkStateRequest {
    /// The name of state store.
    #[prost(string, tag = "1")]
    pub store_name: ::prost::alloc::string::String,
    /// The array of the state key values.
    #[prost(message, repeated, tag = "2")]
    pub states: ::prost::alloc::vec::Vec<super::super::common::v1::StateItem>,
}
/// SaveStateRequest is the message to save multiple states into state store.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SaveStateRequest {
    /// The name of state store.
    #[prost(string, tag = "1")]
    pub store_name: ::prost::alloc::string::String,
    /// The array of the state key values.
    #[prost(message, repeated, tag = "2")]
    pub states: ::prost::alloc::vec::Vec<super::super::common::v1::StateItem>,
}
/// QueryStateRequest is the message to query state store.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryStateRequest {
    /// The name of state store.
    #[prost(string, tag = "1")]
    pub store_name: ::prost::alloc::string::String,
    /// The query in JSON format.
    #[prost(string, tag = "2")]
    pub query: ::prost::alloc::string::String,
    /// The metadata which will be sent to state store components.
    #[prost(map = "string, string", tag = "3")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryStateItem {
    /// The object key.
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    /// The object value.
    #[prost(bytes = "vec", tag = "2")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    /// The entity tag which represents the specific version of data.
    /// ETag format is defined by the corresponding data store.
    #[prost(string, tag = "3")]
    pub etag: ::prost::alloc::string::String,
    /// The error message indicating an error in processing of the query result.
    #[prost(string, tag = "4")]
    pub error: ::prost::alloc::string::String,
}
/// QueryStateResponse is the response conveying the query results.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryStateResponse {
    /// An array of query results.
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<QueryStateItem>,
    /// Pagination token.
    #[prost(string, tag = "2")]
    pub token: ::prost::alloc::string::String,
    /// The metadata which will be sent to app.
    #[prost(map = "string, string", tag = "3")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// PublishEventRequest is the message to publish event data to pubsub topic
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PublishEventRequest {
    /// The name of the pubsub component
    #[prost(string, tag = "1")]
    pub pubsub_name: ::prost::alloc::string::String,
    /// The pubsub topic
    #[prost(string, tag = "2")]
    pub topic: ::prost::alloc::string::String,
    /// The data which will be published to topic.
    #[prost(bytes = "vec", tag = "3")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    /// The content type for the data (optional).
    #[prost(string, tag = "4")]
    pub data_content_type: ::prost::alloc::string::String,
    /// The metadata passing to pub components
    ///
    /// metadata property:
    /// - key : the key of the message.
    #[prost(map = "string, string", tag = "5")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// BulkPublishRequest is the message to bulk publish events to pubsub topic
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BulkPublishRequest {
    /// The name of the pubsub component
    #[prost(string, tag = "1")]
    pub pubsub_name: ::prost::alloc::string::String,
    /// The pubsub topic
    #[prost(string, tag = "2")]
    pub topic: ::prost::alloc::string::String,
    /// The entries which contain the individual events and associated details to be published
    #[prost(message, repeated, tag = "3")]
    pub entries: ::prost::alloc::vec::Vec<BulkPublishRequestEntry>,
    /// The request level metadata passing to to the pubsub components
    #[prost(map = "string, string", tag = "4")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// BulkPublishRequestEntry is the message containing the event to be bulk published
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BulkPublishRequestEntry {
    /// The request scoped unique ID referring to this message. Used to map status in response
    #[prost(string, tag = "1")]
    pub entry_id: ::prost::alloc::string::String,
    /// The event which will be pulished to the topic
    #[prost(bytes = "vec", tag = "2")]
    pub event: ::prost::alloc::vec::Vec<u8>,
    /// The content type for the event
    #[prost(string, tag = "3")]
    pub content_type: ::prost::alloc::string::String,
    /// The event level metadata passing to the pubsub component
    #[prost(map = "string, string", tag = "4")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// BulkPublishResponse is the message returned from a BulkPublishEvent call
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BulkPublishResponse {
    /// The entries for different events that failed publish in the BulkPublishEvent call
    #[prost(message, repeated, tag = "1")]
    pub failed_entries: ::prost::alloc::vec::Vec<BulkPublishResponseFailedEntry>,
}
/// BulkPublishResponseFailedEntry is the message containing the entryID and error of a failed event in BulkPublishEvent call
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BulkPublishResponseFailedEntry {
    /// The response scoped unique ID referring to this message
    #[prost(string, tag = "1")]
    pub entry_id: ::prost::alloc::string::String,
    /// The error message if any on failure
    #[prost(string, tag = "2")]
    pub error: ::prost::alloc::string::String,
}
/// SubscribeTopicEventsRequestAlpha1 is a message containing the details for
/// subscribing to a topic via streaming.
/// The first message must always be the initial request. All subsequent
/// messages must be event processed responses.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeTopicEventsRequestAlpha1 {
    #[prost(
        oneof = "subscribe_topic_events_request_alpha1::SubscribeTopicEventsRequestType",
        tags = "1, 2"
    )]
    pub subscribe_topic_events_request_type: ::core::option::Option<
        subscribe_topic_events_request_alpha1::SubscribeTopicEventsRequestType,
    >,
}
/// Nested message and enum types in `SubscribeTopicEventsRequestAlpha1`.
pub mod subscribe_topic_events_request_alpha1 {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum SubscribeTopicEventsRequestType {
        #[prost(message, tag = "1")]
        InitialRequest(super::SubscribeTopicEventsRequestInitialAlpha1),
        #[prost(message, tag = "2")]
        EventProcessed(super::SubscribeTopicEventsRequestProcessedAlpha1),
    }
}
/// SubscribeTopicEventsRequestInitialAlpha1 is the initial message containing
/// the details for subscribing to a topic via streaming.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeTopicEventsRequestInitialAlpha1 {
    /// The name of the pubsub component
    #[prost(string, tag = "1")]
    pub pubsub_name: ::prost::alloc::string::String,
    /// The pubsub topic
    #[prost(string, tag = "2")]
    pub topic: ::prost::alloc::string::String,
    /// The metadata passing to pub components
    ///
    /// metadata property:
    /// - key : the key of the message.
    #[prost(map = "string, string", tag = "3")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// dead_letter_topic is the topic to which messages that fail to be processed
    /// are sent.
    #[prost(string, optional, tag = "4")]
    pub dead_letter_topic: ::core::option::Option<::prost::alloc::string::String>,
}
/// SubscribeTopicEventsRequestProcessedAlpha1 is the message containing the
/// subscription to a topic.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeTopicEventsRequestProcessedAlpha1 {
    /// id is the unique identifier for the subscription request.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// status is the result of the subscription request.
    #[prost(message, optional, tag = "2")]
    pub status: ::core::option::Option<TopicEventResponse>,
}
/// SubscribeTopicEventsResponseAlpha1 is a message returned from daprd
/// when subscribing to a topic via streaming.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeTopicEventsResponseAlpha1 {
    #[prost(
        oneof = "subscribe_topic_events_response_alpha1::SubscribeTopicEventsResponseType",
        tags = "1, 2"
    )]
    pub subscribe_topic_events_response_type: ::core::option::Option<
        subscribe_topic_events_response_alpha1::SubscribeTopicEventsResponseType,
    >,
}
/// Nested message and enum types in `SubscribeTopicEventsResponseAlpha1`.
pub mod subscribe_topic_events_response_alpha1 {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum SubscribeTopicEventsResponseType {
        #[prost(message, tag = "1")]
        InitialResponse(super::SubscribeTopicEventsResponseInitialAlpha1),
        #[prost(message, tag = "2")]
        EventMessage(super::TopicEventRequest),
    }
}
/// SubscribeTopicEventsResponseInitialAlpha1 is the initial response from daprd
/// when subscribing to a topic.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SubscribeTopicEventsResponseInitialAlpha1 {}
/// InvokeBindingRequest is the message to send data to output bindings
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InvokeBindingRequest {
    /// The name of the output binding to invoke.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The data which will be sent to output binding.
    #[prost(bytes = "vec", tag = "2")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    /// The metadata passing to output binding components
    ///
    /// Common metadata property:
    /// - ttlInSeconds : the time to live in seconds for the message.
    ///
    /// If set in the binding definition will cause all messages to
    /// have a default time to live. The message ttl overrides any value
    /// in the binding definition.
    #[prost(map = "string, string", tag = "3")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// The name of the operation type for the binding to invoke
    #[prost(string, tag = "4")]
    pub operation: ::prost::alloc::string::String,
}
/// InvokeBindingResponse is the message returned from an output binding invocation
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InvokeBindingResponse {
    /// The data which will be sent to output binding.
    #[prost(bytes = "vec", tag = "1")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    /// The metadata returned from an external system
    #[prost(map = "string, string", tag = "2")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// GetSecretRequest is the message to get secret from secret store.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSecretRequest {
    /// The name of secret store.
    #[prost(string, tag = "1")]
    pub store_name: ::prost::alloc::string::String,
    /// The name of secret key.
    #[prost(string, tag = "2")]
    pub key: ::prost::alloc::string::String,
    /// The metadata which will be sent to secret store components.
    #[prost(map = "string, string", tag = "3")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// GetSecretResponse is the response message to convey the requested secret.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSecretResponse {
    /// data is the secret value. Some secret store, such as kubernetes secret
    /// store, can save multiple secrets for single secret key.
    #[prost(map = "string, string", tag = "1")]
    pub data: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// GetBulkSecretRequest is the message to get the secrets from secret store.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBulkSecretRequest {
    /// The name of secret store.
    #[prost(string, tag = "1")]
    pub store_name: ::prost::alloc::string::String,
    /// The metadata which will be sent to secret store components.
    #[prost(map = "string, string", tag = "2")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// SecretResponse is a map of decrypted string/string values
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecretResponse {
    #[prost(map = "string, string", tag = "1")]
    pub secrets: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// GetBulkSecretResponse is the response message to convey the requested secrets.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBulkSecretResponse {
    /// data hold the secret values. Some secret store, such as kubernetes secret
    /// store, can save multiple secrets for single secret key.
    #[prost(map = "string, message", tag = "1")]
    pub data: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        SecretResponse,
    >,
}
/// TransactionalStateOperation is the message to execute a specified operation with a key-value pair.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionalStateOperation {
    /// The type of operation to be executed
    #[prost(string, tag = "1")]
    pub operation_type: ::prost::alloc::string::String,
    /// State values to be operated on
    #[prost(message, optional, tag = "2")]
    pub request: ::core::option::Option<super::super::common::v1::StateItem>,
}
/// ExecuteStateTransactionRequest is the message to execute multiple operations on a specified store.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteStateTransactionRequest {
    /// Required. name of state store.
    #[prost(string, tag = "1")]
    pub store_name: ::prost::alloc::string::String,
    /// Required. transactional operation list.
    #[prost(message, repeated, tag = "2")]
    pub operations: ::prost::alloc::vec::Vec<TransactionalStateOperation>,
    /// The metadata used for transactional operations.
    #[prost(map = "string, string", tag = "3")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// RegisterActorTimerRequest is the message to register a timer for an actor of a given type and id.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterActorTimerRequest {
    #[prost(string, tag = "1")]
    pub actor_type: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub actor_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub due_time: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub period: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub callback: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "7")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "8")]
    pub ttl: ::prost::alloc::string::String,
}
/// UnregisterActorTimerRequest is the message to unregister an actor timer
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnregisterActorTimerRequest {
    #[prost(string, tag = "1")]
    pub actor_type: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub actor_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
}
/// RegisterActorReminderRequest is the message to register a reminder for an actor of a given type and id.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterActorReminderRequest {
    #[prost(string, tag = "1")]
    pub actor_type: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub actor_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub due_time: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub period: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "6")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "7")]
    pub ttl: ::prost::alloc::string::String,
}
/// UnregisterActorReminderRequest is the message to unregister an actor reminder.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnregisterActorReminderRequest {
    #[prost(string, tag = "1")]
    pub actor_type: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub actor_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
}
/// GetActorStateRequest is the message to get key-value states from specific actor.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetActorStateRequest {
    #[prost(string, tag = "1")]
    pub actor_type: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub actor_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub key: ::prost::alloc::string::String,
}
/// GetActorStateResponse is the response conveying the actor's state value.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetActorStateResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    /// The metadata which will be sent to app.
    #[prost(map = "string, string", tag = "2")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// ExecuteActorStateTransactionRequest is the message to execute multiple operations on a specified actor.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteActorStateTransactionRequest {
    #[prost(string, tag = "1")]
    pub actor_type: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub actor_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub operations: ::prost::alloc::vec::Vec<TransactionalActorStateOperation>,
}
/// TransactionalActorStateOperation is the message to execute a specified operation with a key-value pair.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionalActorStateOperation {
    #[prost(string, tag = "1")]
    pub operation_type: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub key: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub value: ::core::option::Option<::prost_types::Any>,
    /// The metadata used for transactional operations.
    ///
    /// Common metadata property:
    /// - ttlInSeconds : the time to live in seconds for the stored value.
    #[prost(map = "string, string", tag = "4")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// InvokeActorRequest is the message to call an actor.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InvokeActorRequest {
    #[prost(string, tag = "1")]
    pub actor_type: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub actor_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub method: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "4")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    #[prost(map = "string, string", tag = "5")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// InvokeActorResponse is the method that returns an actor invocation response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InvokeActorResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
/// GetMetadataRequest is the message for the GetMetadata request.
///
/// Empty
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetMetadataRequest {}
/// GetMetadataResponse is a message that is returned on GetMetadata rpc call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMetadataResponse {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Deprecated alias for actor_runtime.active_actors.
    #[deprecated]
    #[prost(message, repeated, tag = "2")]
    pub active_actors_count: ::prost::alloc::vec::Vec<ActiveActorsCount>,
    #[prost(message, repeated, tag = "3")]
    pub registered_components: ::prost::alloc::vec::Vec<RegisteredComponents>,
    #[prost(map = "string, string", tag = "4")]
    pub extended_metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, repeated, tag = "5")]
    pub subscriptions: ::prost::alloc::vec::Vec<PubsubSubscription>,
    #[prost(message, repeated, tag = "6")]
    pub http_endpoints: ::prost::alloc::vec::Vec<MetadataHttpEndpoint>,
    #[prost(message, optional, tag = "7")]
    pub app_connection_properties: ::core::option::Option<AppConnectionProperties>,
    #[prost(string, tag = "8")]
    pub runtime_version: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "9")]
    pub enabled_features: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// TODO: Cassie: probably add scheduler runtime status
    #[prost(message, optional, tag = "10")]
    pub actor_runtime: ::core::option::Option<ActorRuntime>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActorRuntime {
    /// Contains an enum indicating whether the actor runtime has been initialized.
    #[prost(enumeration = "actor_runtime::ActorRuntimeStatus", tag = "1")]
    pub runtime_status: i32,
    /// Count of active actors per type.
    #[prost(message, repeated, tag = "2")]
    pub active_actors: ::prost::alloc::vec::Vec<ActiveActorsCount>,
    /// Indicates whether the actor runtime is ready to host actors.
    #[prost(bool, tag = "3")]
    pub host_ready: bool,
    /// Custom message from the placement provider.
    #[prost(string, tag = "4")]
    pub placement: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ActorRuntime`.
pub mod actor_runtime {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ActorRuntimeStatus {
        /// Indicates that the actor runtime is still being initialized.
        Initializing = 0,
        /// Indicates that the actor runtime is disabled.
        /// This normally happens when Dapr is started without "placement-host-address"
        Disabled = 1,
        /// Indicates the actor runtime is running, either as an actor host or client.
        Running = 2,
    }
    impl ActorRuntimeStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Initializing => "INITIALIZING",
                Self::Disabled => "DISABLED",
                Self::Running => "RUNNING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INITIALIZING" => Some(Self::Initializing),
                "DISABLED" => Some(Self::Disabled),
                "RUNNING" => Some(Self::Running),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActiveActorsCount {
    #[prost(string, tag = "1")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub count: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisteredComponents {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub version: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "4")]
    pub capabilities: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataHttpEndpoint {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppConnectionProperties {
    #[prost(int32, tag = "1")]
    pub port: i32,
    #[prost(string, tag = "2")]
    pub protocol: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub channel_address: ::prost::alloc::string::String,
    #[prost(int32, tag = "4")]
    pub max_concurrency: i32,
    #[prost(message, optional, tag = "5")]
    pub health: ::core::option::Option<AppConnectionHealthProperties>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppConnectionHealthProperties {
    #[prost(string, tag = "1")]
    pub health_check_path: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub health_probe_interval: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub health_probe_timeout: ::prost::alloc::string::String,
    #[prost(int32, tag = "4")]
    pub health_threshold: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PubsubSubscription {
    #[prost(string, tag = "1")]
    pub pubsub_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub topic: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "3")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "4")]
    pub rules: ::core::option::Option<PubsubSubscriptionRules>,
    #[prost(string, tag = "5")]
    pub dead_letter_topic: ::prost::alloc::string::String,
    #[prost(enumeration = "PubsubSubscriptionType", tag = "6")]
    pub r#type: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PubsubSubscriptionRules {
    #[prost(message, repeated, tag = "1")]
    pub rules: ::prost::alloc::vec::Vec<PubsubSubscriptionRule>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PubsubSubscriptionRule {
    #[prost(string, tag = "1")]
    pub r#match: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub path: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetMetadataRequest {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
}
/// GetConfigurationRequest is the message to get a list of key-value configuration from specified configuration store.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetConfigurationRequest {
    /// Required. The name of configuration store.
    #[prost(string, tag = "1")]
    pub store_name: ::prost::alloc::string::String,
    /// Optional. The key of the configuration item to fetch.
    /// If set, only query for the specified configuration items.
    /// Empty list means fetch all.
    #[prost(string, repeated, tag = "2")]
    pub keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. The metadata which will be sent to configuration store components.
    #[prost(map = "string, string", tag = "3")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// GetConfigurationResponse is the response conveying the list of configuration values.
/// It should be the FULL configuration of specified application which contains all of its configuration items.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetConfigurationResponse {
    #[prost(map = "string, message", tag = "1")]
    pub items: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        super::super::common::v1::ConfigurationItem,
    >,
}
/// SubscribeConfigurationRequest is the message to get a list of key-value configuration from specified configuration store.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeConfigurationRequest {
    /// The name of configuration store.
    #[prost(string, tag = "1")]
    pub store_name: ::prost::alloc::string::String,
    /// Optional. The key of the configuration item to fetch.
    /// If set, only query for the specified configuration items.
    /// Empty list means fetch all.
    #[prost(string, repeated, tag = "2")]
    pub keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The metadata which will be sent to configuration store components.
    #[prost(map = "string, string", tag = "3")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// UnSubscribeConfigurationRequest is the message to stop watching the key-value configuration.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnsubscribeConfigurationRequest {
    /// The name of configuration store.
    #[prost(string, tag = "1")]
    pub store_name: ::prost::alloc::string::String,
    /// The id to unsubscribe.
    #[prost(string, tag = "2")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeConfigurationResponse {
    /// Subscribe id, used to stop subscription.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// The list of items containing configuration values
    #[prost(map = "string, message", tag = "2")]
    pub items: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        super::super::common::v1::ConfigurationItem,
    >,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnsubscribeConfigurationResponse {
    #[prost(bool, tag = "1")]
    pub ok: bool,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TryLockRequest {
    /// Required. The lock store name,e.g. `redis`.
    #[prost(string, tag = "1")]
    pub store_name: ::prost::alloc::string::String,
    /// Required. resource_id is the lock key. e.g. `order_id_111`
    /// It stands for "which resource I want to protect"
    #[prost(string, tag = "2")]
    pub resource_id: ::prost::alloc::string::String,
    /// Required. lock_owner indicate the identifier of lock owner.
    /// You can generate a uuid as lock_owner.For example,in golang:
    ///
    /// req.LockOwner = uuid.New().String()
    ///
    /// This field is per request,not per process,so it is different for each request,
    /// which aims to prevent multi-thread in the same process trying the same lock concurrently.
    ///
    /// The reason why we don't make it automatically generated is:
    /// 1. If it is automatically generated,there must be a 'my_lock_owner_id' field in the response.
    ///    This name is so weird that we think it is inappropriate to put it into the api spec
    /// 2. If we change the field 'my_lock_owner_id' in the response to 'lock_owner',which means the current lock owner of this lock,
    ///    we find that in some lock services users can't get the current lock owner.Actually users don't need it at all.
    /// 3. When reentrant lock is needed,the existing lock_owner is required to identify client and check "whether this client can reenter this lock".
    ///    So this field in the request shouldn't be removed.
    #[prost(string, tag = "3")]
    pub lock_owner: ::prost::alloc::string::String,
    /// Required. The time before expiry.The time unit is second.
    #[prost(int32, tag = "4")]
    pub expiry_in_seconds: i32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TryLockResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnlockRequest {
    #[prost(string, tag = "1")]
    pub store_name: ::prost::alloc::string::String,
    /// resource_id is the lock key.
    #[prost(string, tag = "2")]
    pub resource_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub lock_owner: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UnlockResponse {
    #[prost(enumeration = "unlock_response::Status", tag = "1")]
    pub status: i32,
}
/// Nested message and enum types in `UnlockResponse`.
pub mod unlock_response {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        Success = 0,
        LockDoesNotExist = 1,
        LockBelongsToOthers = 2,
        InternalError = 3,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Success => "SUCCESS",
                Self::LockDoesNotExist => "LOCK_DOES_NOT_EXIST",
                Self::LockBelongsToOthers => "LOCK_BELONGS_TO_OTHERS",
                Self::InternalError => "INTERNAL_ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SUCCESS" => Some(Self::Success),
                "LOCK_DOES_NOT_EXIST" => Some(Self::LockDoesNotExist),
                "LOCK_BELONGS_TO_OTHERS" => Some(Self::LockBelongsToOthers),
                "INTERNAL_ERROR" => Some(Self::InternalError),
                _ => None,
            }
        }
    }
}
/// SubtleGetKeyRequest is the request object for SubtleGetKeyAlpha1.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubtleGetKeyRequest {
    /// Name of the component
    #[prost(string, tag = "1")]
    pub component_name: ::prost::alloc::string::String,
    /// Name (or name/version) of the key to use in the key vault
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Response format
    #[prost(enumeration = "subtle_get_key_request::KeyFormat", tag = "3")]
    pub format: i32,
}
/// Nested message and enum types in `SubtleGetKeyRequest`.
pub mod subtle_get_key_request {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum KeyFormat {
        /// PEM (PKIX) (default)
        Pem = 0,
        /// JSON (JSON Web Key) as string
        Json = 1,
    }
    impl KeyFormat {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Pem => "PEM",
                Self::Json => "JSON",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PEM" => Some(Self::Pem),
                "JSON" => Some(Self::Json),
                _ => None,
            }
        }
    }
}
/// SubtleGetKeyResponse is the response for SubtleGetKeyAlpha1.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubtleGetKeyResponse {
    /// Name (or name/version) of the key.
    /// This is returned as response too in case there is a version.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Public key, encoded in the requested format
    #[prost(string, tag = "2")]
    pub public_key: ::prost::alloc::string::String,
}
/// SubtleEncryptRequest is the request for SubtleEncryptAlpha1.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubtleEncryptRequest {
    /// Name of the component
    #[prost(string, tag = "1")]
    pub component_name: ::prost::alloc::string::String,
    /// Message to encrypt.
    #[prost(bytes = "vec", tag = "2")]
    pub plaintext: ::prost::alloc::vec::Vec<u8>,
    /// Algorithm to use, as in the JWA standard.
    #[prost(string, tag = "3")]
    pub algorithm: ::prost::alloc::string::String,
    /// Name (or name/version) of the key.
    #[prost(string, tag = "4")]
    pub key_name: ::prost::alloc::string::String,
    /// Nonce / initialization vector.
    /// Ignored with asymmetric ciphers.
    #[prost(bytes = "vec", tag = "5")]
    pub nonce: ::prost::alloc::vec::Vec<u8>,
    /// Associated Data when using AEAD ciphers (optional).
    #[prost(bytes = "vec", tag = "6")]
    pub associated_data: ::prost::alloc::vec::Vec<u8>,
}
/// SubtleEncryptResponse is the response for SubtleEncryptAlpha1.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubtleEncryptResponse {
    /// Encrypted ciphertext.
    #[prost(bytes = "vec", tag = "1")]
    pub ciphertext: ::prost::alloc::vec::Vec<u8>,
    /// Authentication tag.
    /// This is nil when not using an authenticated cipher.
    #[prost(bytes = "vec", tag = "2")]
    pub tag: ::prost::alloc::vec::Vec<u8>,
}
/// SubtleDecryptRequest is the request for SubtleDecryptAlpha1.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubtleDecryptRequest {
    /// Name of the component
    #[prost(string, tag = "1")]
    pub component_name: ::prost::alloc::string::String,
    /// Message to decrypt.
    #[prost(bytes = "vec", tag = "2")]
    pub ciphertext: ::prost::alloc::vec::Vec<u8>,
    /// Algorithm to use, as in the JWA standard.
    #[prost(string, tag = "3")]
    pub algorithm: ::prost::alloc::string::String,
    /// Name (or name/version) of the key.
    #[prost(string, tag = "4")]
    pub key_name: ::prost::alloc::string::String,
    /// Nonce / initialization vector.
    /// Ignored with asymmetric ciphers.
    #[prost(bytes = "vec", tag = "5")]
    pub nonce: ::prost::alloc::vec::Vec<u8>,
    /// Authentication tag.
    /// This is nil when not using an authenticated cipher.
    #[prost(bytes = "vec", tag = "6")]
    pub tag: ::prost::alloc::vec::Vec<u8>,
    /// Associated Data when using AEAD ciphers (optional).
    #[prost(bytes = "vec", tag = "7")]
    pub associated_data: ::prost::alloc::vec::Vec<u8>,
}
/// SubtleDecryptResponse is the response for SubtleDecryptAlpha1.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubtleDecryptResponse {
    /// Decrypted plaintext.
    #[prost(bytes = "vec", tag = "1")]
    pub plaintext: ::prost::alloc::vec::Vec<u8>,
}
/// SubtleWrapKeyRequest is the request for SubtleWrapKeyAlpha1.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubtleWrapKeyRequest {
    /// Name of the component
    #[prost(string, tag = "1")]
    pub component_name: ::prost::alloc::string::String,
    /// Key to wrap
    #[prost(bytes = "vec", tag = "2")]
    pub plaintext_key: ::prost::alloc::vec::Vec<u8>,
    /// Algorithm to use, as in the JWA standard.
    #[prost(string, tag = "3")]
    pub algorithm: ::prost::alloc::string::String,
    /// Name (or name/version) of the key.
    #[prost(string, tag = "4")]
    pub key_name: ::prost::alloc::string::String,
    /// Nonce / initialization vector.
    /// Ignored with asymmetric ciphers.
    #[prost(bytes = "vec", tag = "5")]
    pub nonce: ::prost::alloc::vec::Vec<u8>,
    /// Associated Data when using AEAD ciphers (optional).
    #[prost(bytes = "vec", tag = "6")]
    pub associated_data: ::prost::alloc::vec::Vec<u8>,
}
/// SubtleWrapKeyResponse is the response for SubtleWrapKeyAlpha1.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubtleWrapKeyResponse {
    /// Wrapped key.
    #[prost(bytes = "vec", tag = "1")]
    pub wrapped_key: ::prost::alloc::vec::Vec<u8>,
    /// Authentication tag.
    /// This is nil when not using an authenticated cipher.
    #[prost(bytes = "vec", tag = "2")]
    pub tag: ::prost::alloc::vec::Vec<u8>,
}
/// SubtleUnwrapKeyRequest is the request for SubtleUnwrapKeyAlpha1.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubtleUnwrapKeyRequest {
    /// Name of the component
    #[prost(string, tag = "1")]
    pub component_name: ::prost::alloc::string::String,
    /// Wrapped key.
    #[prost(bytes = "vec", tag = "2")]
    pub wrapped_key: ::prost::alloc::vec::Vec<u8>,
    /// Algorithm to use, as in the JWA standard.
    #[prost(string, tag = "3")]
    pub algorithm: ::prost::alloc::string::String,
    /// Name (or name/version) of the key.
    #[prost(string, tag = "4")]
    pub key_name: ::prost::alloc::string::String,
    /// Nonce / initialization vector.
    /// Ignored with asymmetric ciphers.
    #[prost(bytes = "vec", tag = "5")]
    pub nonce: ::prost::alloc::vec::Vec<u8>,
    /// Authentication tag.
    /// This is nil when not using an authenticated cipher.
    #[prost(bytes = "vec", tag = "6")]
    pub tag: ::prost::alloc::vec::Vec<u8>,
    /// Associated Data when using AEAD ciphers (optional).
    #[prost(bytes = "vec", tag = "7")]
    pub associated_data: ::prost::alloc::vec::Vec<u8>,
}
/// SubtleUnwrapKeyResponse is the response for SubtleUnwrapKeyAlpha1.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubtleUnwrapKeyResponse {
    /// Key in plaintext
    #[prost(bytes = "vec", tag = "1")]
    pub plaintext_key: ::prost::alloc::vec::Vec<u8>,
}
/// SubtleSignRequest is the request for SubtleSignAlpha1.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubtleSignRequest {
    /// Name of the component
    #[prost(string, tag = "1")]
    pub component_name: ::prost::alloc::string::String,
    /// Digest to sign.
    #[prost(bytes = "vec", tag = "2")]
    pub digest: ::prost::alloc::vec::Vec<u8>,
    /// Algorithm to use, as in the JWA standard.
    #[prost(string, tag = "3")]
    pub algorithm: ::prost::alloc::string::String,
    /// Name (or name/version) of the key.
    #[prost(string, tag = "4")]
    pub key_name: ::prost::alloc::string::String,
}
/// SubtleSignResponse is the response for SubtleSignAlpha1.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubtleSignResponse {
    /// The signature that was computed
    #[prost(bytes = "vec", tag = "1")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
}
/// SubtleVerifyRequest is the request for SubtleVerifyAlpha1.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubtleVerifyRequest {
    /// Name of the component
    #[prost(string, tag = "1")]
    pub component_name: ::prost::alloc::string::String,
    /// Digest of the message.
    #[prost(bytes = "vec", tag = "2")]
    pub digest: ::prost::alloc::vec::Vec<u8>,
    /// Algorithm to use, as in the JWA standard.
    #[prost(string, tag = "3")]
    pub algorithm: ::prost::alloc::string::String,
    /// Name (or name/version) of the key.
    #[prost(string, tag = "4")]
    pub key_name: ::prost::alloc::string::String,
    /// Signature to verify.
    #[prost(bytes = "vec", tag = "5")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
}
/// SubtleVerifyResponse is the response for SubtleVerifyAlpha1.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SubtleVerifyResponse {
    /// True if the signature is valid.
    #[prost(bool, tag = "1")]
    pub valid: bool,
}
/// EncryptRequest is the request for EncryptAlpha1.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EncryptRequest {
    /// Request details. Must be present in the first message only.
    #[prost(message, optional, tag = "1")]
    pub options: ::core::option::Option<EncryptRequestOptions>,
    /// Chunk of data of arbitrary size.
    #[prost(message, optional, tag = "2")]
    pub payload: ::core::option::Option<super::super::common::v1::StreamPayload>,
}
/// EncryptRequestOptions contains options for the first message in the EncryptAlpha1 request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EncryptRequestOptions {
    /// Name of the component. Required.
    #[prost(string, tag = "1")]
    pub component_name: ::prost::alloc::string::String,
    /// Name (or name/version) of the key. Required.
    #[prost(string, tag = "2")]
    pub key_name: ::prost::alloc::string::String,
    /// Key wrapping algorithm to use. Required.
    /// Supported options include: A256KW (alias: AES), A128CBC, A192CBC, A256CBC, RSA-OAEP-256 (alias: RSA).
    #[prost(string, tag = "3")]
    pub key_wrap_algorithm: ::prost::alloc::string::String,
    /// Cipher used to encrypt data (optional): "aes-gcm" (default) or "chacha20-poly1305"
    #[prost(string, tag = "10")]
    pub data_encryption_cipher: ::prost::alloc::string::String,
    /// If true, the encrypted document does not contain a key reference.
    /// In that case, calls to the Decrypt method must provide a key reference (name or name/version).
    /// Defaults to false.
    #[prost(bool, tag = "11")]
    pub omit_decryption_key_name: bool,
    /// Key reference to embed in the encrypted document (name or name/version).
    /// This is helpful if the reference of the key used to decrypt the document is different from the one used to encrypt it.
    /// If unset, uses the reference of the key used to encrypt the document (this is the default behavior).
    /// This option is ignored if omit_decryption_key_name is true.
    #[prost(string, tag = "12")]
    pub decryption_key_name: ::prost::alloc::string::String,
}
/// EncryptResponse is the response for EncryptAlpha1.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EncryptResponse {
    /// Chunk of data.
    #[prost(message, optional, tag = "1")]
    pub payload: ::core::option::Option<super::super::common::v1::StreamPayload>,
}
/// DecryptRequest is the request for DecryptAlpha1.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DecryptRequest {
    /// Request details. Must be present in the first message only.
    #[prost(message, optional, tag = "1")]
    pub options: ::core::option::Option<DecryptRequestOptions>,
    /// Chunk of data of arbitrary size.
    #[prost(message, optional, tag = "2")]
    pub payload: ::core::option::Option<super::super::common::v1::StreamPayload>,
}
/// DecryptRequestOptions contains options for the first message in the DecryptAlpha1 request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DecryptRequestOptions {
    /// Name of the component
    #[prost(string, tag = "1")]
    pub component_name: ::prost::alloc::string::String,
    /// Name (or name/version) of the key to decrypt the message.
    /// Overrides any key reference included in the message if present.
    /// This is required if the message doesn't include a key reference (i.e. was created with omit_decryption_key_name set to true).
    #[prost(string, tag = "12")]
    pub key_name: ::prost::alloc::string::String,
}
/// DecryptResponse is the response for DecryptAlpha1.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DecryptResponse {
    /// Chunk of data.
    #[prost(message, optional, tag = "1")]
    pub payload: ::core::option::Option<super::super::common::v1::StreamPayload>,
}
/// GetWorkflowRequest is the request for GetWorkflowBeta1.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetWorkflowRequest {
    /// ID of the workflow instance to query.
    #[prost(string, tag = "1")]
    pub instance_id: ::prost::alloc::string::String,
    /// Name of the workflow component.
    #[prost(string, tag = "2")]
    pub workflow_component: ::prost::alloc::string::String,
}
/// GetWorkflowResponse is the response for GetWorkflowBeta1.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetWorkflowResponse {
    /// ID of the workflow instance.
    #[prost(string, tag = "1")]
    pub instance_id: ::prost::alloc::string::String,
    /// Name of the workflow.
    #[prost(string, tag = "2")]
    pub workflow_name: ::prost::alloc::string::String,
    /// The time at which the workflow instance was created.
    #[prost(message, optional, tag = "3")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    /// The last time at which the workflow instance had its state changed.
    #[prost(message, optional, tag = "4")]
    pub last_updated_at: ::core::option::Option<::prost_types::Timestamp>,
    /// The current status of the workflow instance, for example, "PENDING", "RUNNING", "SUSPENDED", "COMPLETED", "FAILED", and "TERMINATED".
    #[prost(string, tag = "5")]
    pub runtime_status: ::prost::alloc::string::String,
    /// Additional component-specific properties of the workflow instance.
    #[prost(map = "string, string", tag = "6")]
    pub properties: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// StartWorkflowRequest is the request for StartWorkflowBeta1.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartWorkflowRequest {
    /// The ID to assign to the started workflow instance. If empty, a random ID is generated.
    #[prost(string, tag = "1")]
    pub instance_id: ::prost::alloc::string::String,
    /// Name of the workflow component.
    #[prost(string, tag = "2")]
    pub workflow_component: ::prost::alloc::string::String,
    /// Name of the workflow.
    #[prost(string, tag = "3")]
    pub workflow_name: ::prost::alloc::string::String,
    /// Additional component-specific options for starting the workflow instance.
    #[prost(map = "string, string", tag = "4")]
    pub options: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Input data for the workflow instance.
    #[prost(bytes = "vec", tag = "5")]
    pub input: ::prost::alloc::vec::Vec<u8>,
}
/// StartWorkflowResponse is the response for StartWorkflowBeta1.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartWorkflowResponse {
    /// ID of the started workflow instance.
    #[prost(string, tag = "1")]
    pub instance_id: ::prost::alloc::string::String,
}
/// TerminateWorkflowRequest is the request for TerminateWorkflowBeta1.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TerminateWorkflowRequest {
    /// ID of the workflow instance to terminate.
    #[prost(string, tag = "1")]
    pub instance_id: ::prost::alloc::string::String,
    /// Name of the workflow component.
    #[prost(string, tag = "2")]
    pub workflow_component: ::prost::alloc::string::String,
}
/// PauseWorkflowRequest is the request for PauseWorkflowBeta1.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PauseWorkflowRequest {
    /// ID of the workflow instance to pause.
    #[prost(string, tag = "1")]
    pub instance_id: ::prost::alloc::string::String,
    /// Name of the workflow component.
    #[prost(string, tag = "2")]
    pub workflow_component: ::prost::alloc::string::String,
}
/// ResumeWorkflowRequest is the request for ResumeWorkflowBeta1.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResumeWorkflowRequest {
    /// ID of the workflow instance to resume.
    #[prost(string, tag = "1")]
    pub instance_id: ::prost::alloc::string::String,
    /// Name of the workflow component.
    #[prost(string, tag = "2")]
    pub workflow_component: ::prost::alloc::string::String,
}
/// RaiseEventWorkflowRequest is the request for RaiseEventWorkflowBeta1.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RaiseEventWorkflowRequest {
    /// ID of the workflow instance to raise an event for.
    #[prost(string, tag = "1")]
    pub instance_id: ::prost::alloc::string::String,
    /// Name of the workflow component.
    #[prost(string, tag = "2")]
    pub workflow_component: ::prost::alloc::string::String,
    /// Name of the event.
    #[prost(string, tag = "3")]
    pub event_name: ::prost::alloc::string::String,
    /// Data associated with the event.
    #[prost(bytes = "vec", tag = "4")]
    pub event_data: ::prost::alloc::vec::Vec<u8>,
}
/// PurgeWorkflowRequest is the request for PurgeWorkflowBeta1.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PurgeWorkflowRequest {
    /// ID of the workflow instance to purge.
    #[prost(string, tag = "1")]
    pub instance_id: ::prost::alloc::string::String,
    /// Name of the workflow component.
    #[prost(string, tag = "2")]
    pub workflow_component: ::prost::alloc::string::String,
}
/// ShutdownRequest is the request for Shutdown.
///
/// Empty
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ShutdownRequest {}
/// Job is the definition of a job. At least one of schedule or due_time must be
/// provided but can also be provided together.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Job {
    /// The unique name for the job.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// schedule is an optional schedule at which the job is to be run.
    /// Accepts both systemd timer style cron expressions, as well as human
    /// readable '@' prefixed period strings as defined below.
    ///
    /// Systemd timer style cron accepts 6 fields:
    /// seconds | minutes | hours | day of month | month        | day of week
    /// 0-59    | 0-59    | 0-23  | 1-31         | 1-12/jan-dec | 0-7/sun-sat
    ///
    /// "0 30 * * * *" - every hour on the half hour
    /// "0 15 3 * * *" - every day at 03:15
    ///
    /// Period string expressions:
    /// Entry                  | Description                                  | Equivalent To
    /// -----                  | -----------                                  | -------------
    /// @every `<duration>`    | Run every `<duration>` (e.g. '@every 1h30m') | N/A
    /// @yearly (or @annually) | Run once a year, midnight, Jan. 1st          | 0 0 0 1 1 *
    /// @monthly               | Run once a month, midnight, first of month   | 0 0 0 1 * *
    /// @weekly                | Run once a week, midnight on Sunday          | 0 0 0 * * 0
    /// @daily (or @midnight)  | Run once a day, midnight                     | 0 0 0 * * *
    /// @hourly                | Run once an hour, beginning of hour          | 0 0 * * * *
    #[prost(string, optional, tag = "2")]
    pub schedule: ::core::option::Option<::prost::alloc::string::String>,
    /// repeats is the optional number of times in which the job should be
    /// triggered. If not set, the job will run indefinitely or until expiration.
    #[prost(uint32, optional, tag = "3")]
    pub repeats: ::core::option::Option<u32>,
    /// due_time is the optional time at which the job should be active, or the
    /// "one shot" time if other scheduling type fields are not provided. Accepts
    /// a "point in time" string in the format of RFC3339, Go duration string
    /// (calculated from job creation time), or non-repeating ISO8601.
    #[prost(string, optional, tag = "4")]
    pub due_time: ::core::option::Option<::prost::alloc::string::String>,
    /// ttl is the optional time to live or expiration of the job. Accepts a
    /// "point in time" string in the format of RFC3339, Go duration string
    /// (calculated from job creation time), or non-repeating ISO8601.
    #[prost(string, optional, tag = "5")]
    pub ttl: ::core::option::Option<::prost::alloc::string::String>,
    /// payload is the serialized job payload that will be sent to the recipient
    /// when the job is triggered.
    #[prost(message, optional, tag = "6")]
    pub data: ::core::option::Option<::prost_types::Any>,
}
/// ScheduleJobRequest is the message to create/schedule the job.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScheduleJobRequest {
    /// The job details.
    #[prost(message, optional, tag = "1")]
    pub job: ::core::option::Option<Job>,
}
/// ScheduleJobResponse is the message response to create/schedule the job.
///
/// Empty
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ScheduleJobResponse {}
/// GetJobRequest is the message to retrieve a job.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetJobRequest {
    /// The name of the job.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// GetJobResponse is the message's response for a job retrieved.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetJobResponse {
    /// The job details.
    #[prost(message, optional, tag = "1")]
    pub job: ::core::option::Option<Job>,
}
/// DeleteJobRequest is the message to delete the job by name.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteJobRequest {
    /// The name of the job.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// DeleteJobResponse is the message response to delete the job by name.
///
/// Empty
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteJobResponse {}
/// PubsubSubscriptionType indicates the type of subscription
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PubsubSubscriptionType {
    /// UNKNOWN is the default value for the subscription type.
    Unknown = 0,
    /// Declarative subscription (k8s CRD)
    Declarative = 1,
    /// Programmatically created subscription
    Programmatic = 2,
    /// Bidirectional Streaming subscription
    Streaming = 3,
}
impl PubsubSubscriptionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "UNKNOWN",
            Self::Declarative => "DECLARATIVE",
            Self::Programmatic => "PROGRAMMATIC",
            Self::Streaming => "STREAMING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNKNOWN" => Some(Self::Unknown),
            "DECLARATIVE" => Some(Self::Declarative),
            "PROGRAMMATIC" => Some(Self::Programmatic),
            "STREAMING" => Some(Self::Streaming),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod dapr_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Dapr service provides APIs to user application to access Dapr building blocks.
    #[derive(Debug, Clone)]
    pub struct DaprClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl DaprClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> DaprClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> DaprClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            DaprClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Invokes a method on a remote Dapr app.
        /// Deprecated: Use proxy mode service invocation instead.
        pub async fn invoke_service(
            &mut self,
            request: impl tonic::IntoRequest<super::InvokeServiceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::common::v1::InvokeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/InvokeService",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("dapr.proto.runtime.v1.Dapr", "InvokeService"));
            self.inner.unary(req, path, codec).await
        }
        /// Gets the state for a specific key.
        pub async fn get_state(
            &mut self,
            request: impl tonic::IntoRequest<super::GetStateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetStateResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/GetState",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("dapr.proto.runtime.v1.Dapr", "GetState"));
            self.inner.unary(req, path, codec).await
        }
        /// Gets a bulk of state items for a list of keys
        pub async fn get_bulk_state(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBulkStateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetBulkStateResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/GetBulkState",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("dapr.proto.runtime.v1.Dapr", "GetBulkState"));
            self.inner.unary(req, path, codec).await
        }
        /// Saves the state for a specific key.
        pub async fn save_state(
            &mut self,
            request: impl tonic::IntoRequest<super::SaveStateRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/SaveState",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("dapr.proto.runtime.v1.Dapr", "SaveState"));
            self.inner.unary(req, path, codec).await
        }
        /// Queries the state.
        pub async fn query_state_alpha1(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryStateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryStateResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/QueryStateAlpha1",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("dapr.proto.runtime.v1.Dapr", "QueryStateAlpha1"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the state for a specific key.
        pub async fn delete_state(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteStateRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/DeleteState",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("dapr.proto.runtime.v1.Dapr", "DeleteState"));
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a bulk of state items for a list of keys
        pub async fn delete_bulk_state(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteBulkStateRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/DeleteBulkState",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("dapr.proto.runtime.v1.Dapr", "DeleteBulkState"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Executes transactions for a specified store
        pub async fn execute_state_transaction(
            &mut self,
            request: impl tonic::IntoRequest<super::ExecuteStateTransactionRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/ExecuteStateTransaction",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "dapr.proto.runtime.v1.Dapr",
                        "ExecuteStateTransaction",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Publishes events to the specific topic.
        pub async fn publish_event(
            &mut self,
            request: impl tonic::IntoRequest<super::PublishEventRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/PublishEvent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("dapr.proto.runtime.v1.Dapr", "PublishEvent"));
            self.inner.unary(req, path, codec).await
        }
        /// Bulk Publishes multiple events to the specified topic.
        pub async fn bulk_publish_event_alpha1(
            &mut self,
            request: impl tonic::IntoRequest<super::BulkPublishRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BulkPublishResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/BulkPublishEventAlpha1",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "dapr.proto.runtime.v1.Dapr",
                        "BulkPublishEventAlpha1",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// SubscribeTopicEventsAlpha1 subscribes to a PubSub topic and receives topic
        /// events from it.
        pub async fn subscribe_topic_events_alpha1(
            &mut self,
            request: impl tonic::IntoStreamingRequest<
                Message = super::SubscribeTopicEventsRequestAlpha1,
            >,
        ) -> std::result::Result<
            tonic::Response<
                tonic::codec::Streaming<super::SubscribeTopicEventsResponseAlpha1>,
            >,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/SubscribeTopicEventsAlpha1",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "dapr.proto.runtime.v1.Dapr",
                        "SubscribeTopicEventsAlpha1",
                    ),
                );
            self.inner.streaming(req, path, codec).await
        }
        /// Invokes binding data to specific output bindings
        pub async fn invoke_binding(
            &mut self,
            request: impl tonic::IntoRequest<super::InvokeBindingRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InvokeBindingResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/InvokeBinding",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("dapr.proto.runtime.v1.Dapr", "InvokeBinding"));
            self.inner.unary(req, path, codec).await
        }
        /// Gets secrets from secret stores.
        pub async fn get_secret(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSecretRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetSecretResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/GetSecret",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("dapr.proto.runtime.v1.Dapr", "GetSecret"));
            self.inner.unary(req, path, codec).await
        }
        /// Gets a bulk of secrets
        pub async fn get_bulk_secret(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBulkSecretRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetBulkSecretResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/GetBulkSecret",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("dapr.proto.runtime.v1.Dapr", "GetBulkSecret"));
            self.inner.unary(req, path, codec).await
        }
        /// Register an actor timer.
        pub async fn register_actor_timer(
            &mut self,
            request: impl tonic::IntoRequest<super::RegisterActorTimerRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/RegisterActorTimer",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("dapr.proto.runtime.v1.Dapr", "RegisterActorTimer"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Unregister an actor timer.
        pub async fn unregister_actor_timer(
            &mut self,
            request: impl tonic::IntoRequest<super::UnregisterActorTimerRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/UnregisterActorTimer",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("dapr.proto.runtime.v1.Dapr", "UnregisterActorTimer"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Register an actor reminder.
        pub async fn register_actor_reminder(
            &mut self,
            request: impl tonic::IntoRequest<super::RegisterActorReminderRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/RegisterActorReminder",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "dapr.proto.runtime.v1.Dapr",
                        "RegisterActorReminder",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Unregister an actor reminder.
        pub async fn unregister_actor_reminder(
            &mut self,
            request: impl tonic::IntoRequest<super::UnregisterActorReminderRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/UnregisterActorReminder",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "dapr.proto.runtime.v1.Dapr",
                        "UnregisterActorReminder",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the state for a specific actor.
        pub async fn get_actor_state(
            &mut self,
            request: impl tonic::IntoRequest<super::GetActorStateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetActorStateResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/GetActorState",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("dapr.proto.runtime.v1.Dapr", "GetActorState"));
            self.inner.unary(req, path, codec).await
        }
        /// Executes state transactions for a specified actor
        pub async fn execute_actor_state_transaction(
            &mut self,
            request: impl tonic::IntoRequest<super::ExecuteActorStateTransactionRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/ExecuteActorStateTransaction",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "dapr.proto.runtime.v1.Dapr",
                        "ExecuteActorStateTransaction",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// InvokeActor calls a method on an actor.
        pub async fn invoke_actor(
            &mut self,
            request: impl tonic::IntoRequest<super::InvokeActorRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InvokeActorResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/InvokeActor",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("dapr.proto.runtime.v1.Dapr", "InvokeActor"));
            self.inner.unary(req, path, codec).await
        }
        /// GetConfiguration gets configuration from configuration store.
        pub async fn get_configuration_alpha1(
            &mut self,
            request: impl tonic::IntoRequest<super::GetConfigurationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetConfigurationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/GetConfigurationAlpha1",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "dapr.proto.runtime.v1.Dapr",
                        "GetConfigurationAlpha1",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// GetConfiguration gets configuration from configuration store.
        pub async fn get_configuration(
            &mut self,
            request: impl tonic::IntoRequest<super::GetConfigurationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetConfigurationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/GetConfiguration",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("dapr.proto.runtime.v1.Dapr", "GetConfiguration"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// SubscribeConfiguration gets configuration from configuration store and subscribe the updates event by grpc stream
        pub async fn subscribe_configuration_alpha1(
            &mut self,
            request: impl tonic::IntoRequest<super::SubscribeConfigurationRequest>,
        ) -> std::result::Result<
            tonic::Response<
                tonic::codec::Streaming<super::SubscribeConfigurationResponse>,
            >,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/SubscribeConfigurationAlpha1",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "dapr.proto.runtime.v1.Dapr",
                        "SubscribeConfigurationAlpha1",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// SubscribeConfiguration gets configuration from configuration store and subscribe the updates event by grpc stream
        pub async fn subscribe_configuration(
            &mut self,
            request: impl tonic::IntoRequest<super::SubscribeConfigurationRequest>,
        ) -> std::result::Result<
            tonic::Response<
                tonic::codec::Streaming<super::SubscribeConfigurationResponse>,
            >,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/SubscribeConfiguration",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "dapr.proto.runtime.v1.Dapr",
                        "SubscribeConfiguration",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// UnSubscribeConfiguration unsubscribe the subscription of configuration
        pub async fn unsubscribe_configuration_alpha1(
            &mut self,
            request: impl tonic::IntoRequest<super::UnsubscribeConfigurationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UnsubscribeConfigurationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/UnsubscribeConfigurationAlpha1",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "dapr.proto.runtime.v1.Dapr",
                        "UnsubscribeConfigurationAlpha1",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// UnSubscribeConfiguration unsubscribe the subscription of configuration
        pub async fn unsubscribe_configuration(
            &mut self,
            request: impl tonic::IntoRequest<super::UnsubscribeConfigurationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UnsubscribeConfigurationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/UnsubscribeConfiguration",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "dapr.proto.runtime.v1.Dapr",
                        "UnsubscribeConfiguration",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// TryLockAlpha1 tries to get a lock with an expiry.
        pub async fn try_lock_alpha1(
            &mut self,
            request: impl tonic::IntoRequest<super::TryLockRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TryLockResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/TryLockAlpha1",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("dapr.proto.runtime.v1.Dapr", "TryLockAlpha1"));
            self.inner.unary(req, path, codec).await
        }
        /// UnlockAlpha1 unlocks a lock.
        pub async fn unlock_alpha1(
            &mut self,
            request: impl tonic::IntoRequest<super::UnlockRequest>,
        ) -> std::result::Result<tonic::Response<super::UnlockResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/UnlockAlpha1",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("dapr.proto.runtime.v1.Dapr", "UnlockAlpha1"));
            self.inner.unary(req, path, codec).await
        }
        /// EncryptAlpha1 encrypts a message using the Dapr encryption scheme and a key stored in the vault.
        pub async fn encrypt_alpha1(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::EncryptRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::EncryptResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/EncryptAlpha1",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("dapr.proto.runtime.v1.Dapr", "EncryptAlpha1"));
            self.inner.streaming(req, path, codec).await
        }
        /// DecryptAlpha1 decrypts a message using the Dapr encryption scheme and a key stored in the vault.
        pub async fn decrypt_alpha1(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::DecryptRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::DecryptResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/DecryptAlpha1",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("dapr.proto.runtime.v1.Dapr", "DecryptAlpha1"));
            self.inner.streaming(req, path, codec).await
        }
        /// Gets metadata of the sidecar
        pub async fn get_metadata(
            &mut self,
            request: impl tonic::IntoRequest<super::GetMetadataRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetMetadataResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/GetMetadata",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("dapr.proto.runtime.v1.Dapr", "GetMetadata"));
            self.inner.unary(req, path, codec).await
        }
        /// Sets value in extended metadata of the sidecar
        pub async fn set_metadata(
            &mut self,
            request: impl tonic::IntoRequest<super::SetMetadataRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/SetMetadata",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("dapr.proto.runtime.v1.Dapr", "SetMetadata"));
            self.inner.unary(req, path, codec).await
        }
        /// SubtleGetKeyAlpha1 returns the public part of an asymmetric key stored in the vault.
        pub async fn subtle_get_key_alpha1(
            &mut self,
            request: impl tonic::IntoRequest<super::SubtleGetKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SubtleGetKeyResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/SubtleGetKeyAlpha1",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("dapr.proto.runtime.v1.Dapr", "SubtleGetKeyAlpha1"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// SubtleEncryptAlpha1 encrypts a small message using a key stored in the vault.
        pub async fn subtle_encrypt_alpha1(
            &mut self,
            request: impl tonic::IntoRequest<super::SubtleEncryptRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SubtleEncryptResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/SubtleEncryptAlpha1",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("dapr.proto.runtime.v1.Dapr", "SubtleEncryptAlpha1"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// SubtleDecryptAlpha1 decrypts a small message using a key stored in the vault.
        pub async fn subtle_decrypt_alpha1(
            &mut self,
            request: impl tonic::IntoRequest<super::SubtleDecryptRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SubtleDecryptResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/SubtleDecryptAlpha1",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("dapr.proto.runtime.v1.Dapr", "SubtleDecryptAlpha1"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// SubtleWrapKeyAlpha1 wraps a key using a key stored in the vault.
        pub async fn subtle_wrap_key_alpha1(
            &mut self,
            request: impl tonic::IntoRequest<super::SubtleWrapKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SubtleWrapKeyResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/SubtleWrapKeyAlpha1",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("dapr.proto.runtime.v1.Dapr", "SubtleWrapKeyAlpha1"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// SubtleUnwrapKeyAlpha1 unwraps a key using a key stored in the vault.
        pub async fn subtle_unwrap_key_alpha1(
            &mut self,
            request: impl tonic::IntoRequest<super::SubtleUnwrapKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SubtleUnwrapKeyResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/SubtleUnwrapKeyAlpha1",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "dapr.proto.runtime.v1.Dapr",
                        "SubtleUnwrapKeyAlpha1",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// SubtleSignAlpha1 signs a message using a key stored in the vault.
        pub async fn subtle_sign_alpha1(
            &mut self,
            request: impl tonic::IntoRequest<super::SubtleSignRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SubtleSignResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/SubtleSignAlpha1",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("dapr.proto.runtime.v1.Dapr", "SubtleSignAlpha1"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// SubtleVerifyAlpha1 verifies the signature of a message using a key stored in the vault.
        pub async fn subtle_verify_alpha1(
            &mut self,
            request: impl tonic::IntoRequest<super::SubtleVerifyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SubtleVerifyResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/SubtleVerifyAlpha1",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("dapr.proto.runtime.v1.Dapr", "SubtleVerifyAlpha1"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Starts a new instance of a workflow
        pub async fn start_workflow_alpha1(
            &mut self,
            request: impl tonic::IntoRequest<super::StartWorkflowRequest>,
        ) -> std::result::Result<
            tonic::Response<super::StartWorkflowResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/StartWorkflowAlpha1",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("dapr.proto.runtime.v1.Dapr", "StartWorkflowAlpha1"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details about a started workflow instance
        pub async fn get_workflow_alpha1(
            &mut self,
            request: impl tonic::IntoRequest<super::GetWorkflowRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetWorkflowResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/GetWorkflowAlpha1",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("dapr.proto.runtime.v1.Dapr", "GetWorkflowAlpha1"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Purge Workflow
        pub async fn purge_workflow_alpha1(
            &mut self,
            request: impl tonic::IntoRequest<super::PurgeWorkflowRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/PurgeWorkflowAlpha1",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("dapr.proto.runtime.v1.Dapr", "PurgeWorkflowAlpha1"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Terminates a running workflow instance
        pub async fn terminate_workflow_alpha1(
            &mut self,
            request: impl tonic::IntoRequest<super::TerminateWorkflowRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/TerminateWorkflowAlpha1",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "dapr.proto.runtime.v1.Dapr",
                        "TerminateWorkflowAlpha1",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Pauses a running workflow instance
        pub async fn pause_workflow_alpha1(
            &mut self,
            request: impl tonic::IntoRequest<super::PauseWorkflowRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/PauseWorkflowAlpha1",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("dapr.proto.runtime.v1.Dapr", "PauseWorkflowAlpha1"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Resumes a paused workflow instance
        pub async fn resume_workflow_alpha1(
            &mut self,
            request: impl tonic::IntoRequest<super::ResumeWorkflowRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/ResumeWorkflowAlpha1",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("dapr.proto.runtime.v1.Dapr", "ResumeWorkflowAlpha1"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Raise an event to a running workflow instance
        pub async fn raise_event_workflow_alpha1(
            &mut self,
            request: impl tonic::IntoRequest<super::RaiseEventWorkflowRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/RaiseEventWorkflowAlpha1",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "dapr.proto.runtime.v1.Dapr",
                        "RaiseEventWorkflowAlpha1",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Starts a new instance of a workflow
        pub async fn start_workflow_beta1(
            &mut self,
            request: impl tonic::IntoRequest<super::StartWorkflowRequest>,
        ) -> std::result::Result<
            tonic::Response<super::StartWorkflowResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/StartWorkflowBeta1",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("dapr.proto.runtime.v1.Dapr", "StartWorkflowBeta1"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details about a started workflow instance
        pub async fn get_workflow_beta1(
            &mut self,
            request: impl tonic::IntoRequest<super::GetWorkflowRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetWorkflowResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/GetWorkflowBeta1",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("dapr.proto.runtime.v1.Dapr", "GetWorkflowBeta1"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Purge Workflow
        pub async fn purge_workflow_beta1(
            &mut self,
            request: impl tonic::IntoRequest<super::PurgeWorkflowRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/PurgeWorkflowBeta1",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("dapr.proto.runtime.v1.Dapr", "PurgeWorkflowBeta1"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Terminates a running workflow instance
        pub async fn terminate_workflow_beta1(
            &mut self,
            request: impl tonic::IntoRequest<super::TerminateWorkflowRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/TerminateWorkflowBeta1",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "dapr.proto.runtime.v1.Dapr",
                        "TerminateWorkflowBeta1",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Pauses a running workflow instance
        pub async fn pause_workflow_beta1(
            &mut self,
            request: impl tonic::IntoRequest<super::PauseWorkflowRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/PauseWorkflowBeta1",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("dapr.proto.runtime.v1.Dapr", "PauseWorkflowBeta1"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Resumes a paused workflow instance
        pub async fn resume_workflow_beta1(
            &mut self,
            request: impl tonic::IntoRequest<super::ResumeWorkflowRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/ResumeWorkflowBeta1",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("dapr.proto.runtime.v1.Dapr", "ResumeWorkflowBeta1"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Raise an event to a running workflow instance
        pub async fn raise_event_workflow_beta1(
            &mut self,
            request: impl tonic::IntoRequest<super::RaiseEventWorkflowRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/RaiseEventWorkflowBeta1",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "dapr.proto.runtime.v1.Dapr",
                        "RaiseEventWorkflowBeta1",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Shutdown the sidecar
        pub async fn shutdown(
            &mut self,
            request: impl tonic::IntoRequest<super::ShutdownRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/Shutdown",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("dapr.proto.runtime.v1.Dapr", "Shutdown"));
            self.inner.unary(req, path, codec).await
        }
        /// Create and schedule a job
        pub async fn schedule_job_alpha1(
            &mut self,
            request: impl tonic::IntoRequest<super::ScheduleJobRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ScheduleJobResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/ScheduleJobAlpha1",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("dapr.proto.runtime.v1.Dapr", "ScheduleJobAlpha1"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a scheduled job
        pub async fn get_job_alpha1(
            &mut self,
            request: impl tonic::IntoRequest<super::GetJobRequest>,
        ) -> std::result::Result<tonic::Response<super::GetJobResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/GetJobAlpha1",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("dapr.proto.runtime.v1.Dapr", "GetJobAlpha1"));
            self.inner.unary(req, path, codec).await
        }
        /// Delete a job
        pub async fn delete_job_alpha1(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteJobRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteJobResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/dapr.proto.runtime.v1.Dapr/DeleteJobAlpha1",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("dapr.proto.runtime.v1.Dapr", "DeleteJobAlpha1"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod dapr_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with DaprServer.
    #[async_trait]
    pub trait Dapr: std::marker::Send + std::marker::Sync + 'static {
        /// Invokes a method on a remote Dapr app.
        /// Deprecated: Use proxy mode service invocation instead.
        async fn invoke_service(
            &self,
            request: tonic::Request<super::InvokeServiceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::common::v1::InvokeResponse>,
            tonic::Status,
        >;
        /// Gets the state for a specific key.
        async fn get_state(
            &self,
            request: tonic::Request<super::GetStateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetStateResponse>,
            tonic::Status,
        >;
        /// Gets a bulk of state items for a list of keys
        async fn get_bulk_state(
            &self,
            request: tonic::Request<super::GetBulkStateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetBulkStateResponse>,
            tonic::Status,
        >;
        /// Saves the state for a specific key.
        async fn save_state(
            &self,
            request: tonic::Request<super::SaveStateRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Queries the state.
        async fn query_state_alpha1(
            &self,
            request: tonic::Request<super::QueryStateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryStateResponse>,
            tonic::Status,
        >;
        /// Deletes the state for a specific key.
        async fn delete_state(
            &self,
            request: tonic::Request<super::DeleteStateRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Deletes a bulk of state items for a list of keys
        async fn delete_bulk_state(
            &self,
            request: tonic::Request<super::DeleteBulkStateRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Executes transactions for a specified store
        async fn execute_state_transaction(
            &self,
            request: tonic::Request<super::ExecuteStateTransactionRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Publishes events to the specific topic.
        async fn publish_event(
            &self,
            request: tonic::Request<super::PublishEventRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Bulk Publishes multiple events to the specified topic.
        async fn bulk_publish_event_alpha1(
            &self,
            request: tonic::Request<super::BulkPublishRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BulkPublishResponse>,
            tonic::Status,
        >;
        /// Server streaming response type for the SubscribeTopicEventsAlpha1 method.
        type SubscribeTopicEventsAlpha1Stream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<
                    super::SubscribeTopicEventsResponseAlpha1,
                    tonic::Status,
                >,
            >
            + std::marker::Send
            + 'static;
        /// SubscribeTopicEventsAlpha1 subscribes to a PubSub topic and receives topic
        /// events from it.
        async fn subscribe_topic_events_alpha1(
            &self,
            request: tonic::Request<
                tonic::Streaming<super::SubscribeTopicEventsRequestAlpha1>,
            >,
        ) -> std::result::Result<
            tonic::Response<Self::SubscribeTopicEventsAlpha1Stream>,
            tonic::Status,
        >;
        /// Invokes binding data to specific output bindings
        async fn invoke_binding(
            &self,
            request: tonic::Request<super::InvokeBindingRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InvokeBindingResponse>,
            tonic::Status,
        >;
        /// Gets secrets from secret stores.
        async fn get_secret(
            &self,
            request: tonic::Request<super::GetSecretRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetSecretResponse>,
            tonic::Status,
        >;
        /// Gets a bulk of secrets
        async fn get_bulk_secret(
            &self,
            request: tonic::Request<super::GetBulkSecretRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetBulkSecretResponse>,
            tonic::Status,
        >;
        /// Register an actor timer.
        async fn register_actor_timer(
            &self,
            request: tonic::Request<super::RegisterActorTimerRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Unregister an actor timer.
        async fn unregister_actor_timer(
            &self,
            request: tonic::Request<super::UnregisterActorTimerRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Register an actor reminder.
        async fn register_actor_reminder(
            &self,
            request: tonic::Request<super::RegisterActorReminderRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Unregister an actor reminder.
        async fn unregister_actor_reminder(
            &self,
            request: tonic::Request<super::UnregisterActorReminderRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Gets the state for a specific actor.
        async fn get_actor_state(
            &self,
            request: tonic::Request<super::GetActorStateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetActorStateResponse>,
            tonic::Status,
        >;
        /// Executes state transactions for a specified actor
        async fn execute_actor_state_transaction(
            &self,
            request: tonic::Request<super::ExecuteActorStateTransactionRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// InvokeActor calls a method on an actor.
        async fn invoke_actor(
            &self,
            request: tonic::Request<super::InvokeActorRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InvokeActorResponse>,
            tonic::Status,
        >;
        /// GetConfiguration gets configuration from configuration store.
        async fn get_configuration_alpha1(
            &self,
            request: tonic::Request<super::GetConfigurationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetConfigurationResponse>,
            tonic::Status,
        >;
        /// GetConfiguration gets configuration from configuration store.
        async fn get_configuration(
            &self,
            request: tonic::Request<super::GetConfigurationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetConfigurationResponse>,
            tonic::Status,
        >;
        /// Server streaming response type for the SubscribeConfigurationAlpha1 method.
        type SubscribeConfigurationAlpha1Stream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<
                    super::SubscribeConfigurationResponse,
                    tonic::Status,
                >,
            >
            + std::marker::Send
            + 'static;
        /// SubscribeConfiguration gets configuration from configuration store and subscribe the updates event by grpc stream
        async fn subscribe_configuration_alpha1(
            &self,
            request: tonic::Request<super::SubscribeConfigurationRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::SubscribeConfigurationAlpha1Stream>,
            tonic::Status,
        >;
        /// Server streaming response type for the SubscribeConfiguration method.
        type SubscribeConfigurationStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<
                    super::SubscribeConfigurationResponse,
                    tonic::Status,
                >,
            >
            + std::marker::Send
            + 'static;
        /// SubscribeConfiguration gets configuration from configuration store and subscribe the updates event by grpc stream
        async fn subscribe_configuration(
            &self,
            request: tonic::Request<super::SubscribeConfigurationRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::SubscribeConfigurationStream>,
            tonic::Status,
        >;
        /// UnSubscribeConfiguration unsubscribe the subscription of configuration
        async fn unsubscribe_configuration_alpha1(
            &self,
            request: tonic::Request<super::UnsubscribeConfigurationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UnsubscribeConfigurationResponse>,
            tonic::Status,
        >;
        /// UnSubscribeConfiguration unsubscribe the subscription of configuration
        async fn unsubscribe_configuration(
            &self,
            request: tonic::Request<super::UnsubscribeConfigurationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UnsubscribeConfigurationResponse>,
            tonic::Status,
        >;
        /// TryLockAlpha1 tries to get a lock with an expiry.
        async fn try_lock_alpha1(
            &self,
            request: tonic::Request<super::TryLockRequest>,
        ) -> std::result::Result<tonic::Response<super::TryLockResponse>, tonic::Status>;
        /// UnlockAlpha1 unlocks a lock.
        async fn unlock_alpha1(
            &self,
            request: tonic::Request<super::UnlockRequest>,
        ) -> std::result::Result<tonic::Response<super::UnlockResponse>, tonic::Status>;
        /// Server streaming response type for the EncryptAlpha1 method.
        type EncryptAlpha1Stream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::EncryptResponse, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// EncryptAlpha1 encrypts a message using the Dapr encryption scheme and a key stored in the vault.
        async fn encrypt_alpha1(
            &self,
            request: tonic::Request<tonic::Streaming<super::EncryptRequest>>,
        ) -> std::result::Result<
            tonic::Response<Self::EncryptAlpha1Stream>,
            tonic::Status,
        >;
        /// Server streaming response type for the DecryptAlpha1 method.
        type DecryptAlpha1Stream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::DecryptResponse, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// DecryptAlpha1 decrypts a message using the Dapr encryption scheme and a key stored in the vault.
        async fn decrypt_alpha1(
            &self,
            request: tonic::Request<tonic::Streaming<super::DecryptRequest>>,
        ) -> std::result::Result<
            tonic::Response<Self::DecryptAlpha1Stream>,
            tonic::Status,
        >;
        /// Gets metadata of the sidecar
        async fn get_metadata(
            &self,
            request: tonic::Request<super::GetMetadataRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetMetadataResponse>,
            tonic::Status,
        >;
        /// Sets value in extended metadata of the sidecar
        async fn set_metadata(
            &self,
            request: tonic::Request<super::SetMetadataRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// SubtleGetKeyAlpha1 returns the public part of an asymmetric key stored in the vault.
        async fn subtle_get_key_alpha1(
            &self,
            request: tonic::Request<super::SubtleGetKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SubtleGetKeyResponse>,
            tonic::Status,
        >;
        /// SubtleEncryptAlpha1 encrypts a small message using a key stored in the vault.
        async fn subtle_encrypt_alpha1(
            &self,
            request: tonic::Request<super::SubtleEncryptRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SubtleEncryptResponse>,
            tonic::Status,
        >;
        /// SubtleDecryptAlpha1 decrypts a small message using a key stored in the vault.
        async fn subtle_decrypt_alpha1(
            &self,
            request: tonic::Request<super::SubtleDecryptRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SubtleDecryptResponse>,
            tonic::Status,
        >;
        /// SubtleWrapKeyAlpha1 wraps a key using a key stored in the vault.
        async fn subtle_wrap_key_alpha1(
            &self,
            request: tonic::Request<super::SubtleWrapKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SubtleWrapKeyResponse>,
            tonic::Status,
        >;
        /// SubtleUnwrapKeyAlpha1 unwraps a key using a key stored in the vault.
        async fn subtle_unwrap_key_alpha1(
            &self,
            request: tonic::Request<super::SubtleUnwrapKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SubtleUnwrapKeyResponse>,
            tonic::Status,
        >;
        /// SubtleSignAlpha1 signs a message using a key stored in the vault.
        async fn subtle_sign_alpha1(
            &self,
            request: tonic::Request<super::SubtleSignRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SubtleSignResponse>,
            tonic::Status,
        >;
        /// SubtleVerifyAlpha1 verifies the signature of a message using a key stored in the vault.
        async fn subtle_verify_alpha1(
            &self,
            request: tonic::Request<super::SubtleVerifyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SubtleVerifyResponse>,
            tonic::Status,
        >;
        /// Starts a new instance of a workflow
        async fn start_workflow_alpha1(
            &self,
            request: tonic::Request<super::StartWorkflowRequest>,
        ) -> std::result::Result<
            tonic::Response<super::StartWorkflowResponse>,
            tonic::Status,
        >;
        /// Gets details about a started workflow instance
        async fn get_workflow_alpha1(
            &self,
            request: tonic::Request<super::GetWorkflowRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetWorkflowResponse>,
            tonic::Status,
        >;
        /// Purge Workflow
        async fn purge_workflow_alpha1(
            &self,
            request: tonic::Request<super::PurgeWorkflowRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Terminates a running workflow instance
        async fn terminate_workflow_alpha1(
            &self,
            request: tonic::Request<super::TerminateWorkflowRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Pauses a running workflow instance
        async fn pause_workflow_alpha1(
            &self,
            request: tonic::Request<super::PauseWorkflowRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Resumes a paused workflow instance
        async fn resume_workflow_alpha1(
            &self,
            request: tonic::Request<super::ResumeWorkflowRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Raise an event to a running workflow instance
        async fn raise_event_workflow_alpha1(
            &self,
            request: tonic::Request<super::RaiseEventWorkflowRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Starts a new instance of a workflow
        async fn start_workflow_beta1(
            &self,
            request: tonic::Request<super::StartWorkflowRequest>,
        ) -> std::result::Result<
            tonic::Response<super::StartWorkflowResponse>,
            tonic::Status,
        >;
        /// Gets details about a started workflow instance
        async fn get_workflow_beta1(
            &self,
            request: tonic::Request<super::GetWorkflowRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetWorkflowResponse>,
            tonic::Status,
        >;
        /// Purge Workflow
        async fn purge_workflow_beta1(
            &self,
            request: tonic::Request<super::PurgeWorkflowRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Terminates a running workflow instance
        async fn terminate_workflow_beta1(
            &self,
            request: tonic::Request<super::TerminateWorkflowRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Pauses a running workflow instance
        async fn pause_workflow_beta1(
            &self,
            request: tonic::Request<super::PauseWorkflowRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Resumes a paused workflow instance
        async fn resume_workflow_beta1(
            &self,
            request: tonic::Request<super::ResumeWorkflowRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Raise an event to a running workflow instance
        async fn raise_event_workflow_beta1(
            &self,
            request: tonic::Request<super::RaiseEventWorkflowRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Shutdown the sidecar
        async fn shutdown(
            &self,
            request: tonic::Request<super::ShutdownRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Create and schedule a job
        async fn schedule_job_alpha1(
            &self,
            request: tonic::Request<super::ScheduleJobRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ScheduleJobResponse>,
            tonic::Status,
        >;
        /// Gets a scheduled job
        async fn get_job_alpha1(
            &self,
            request: tonic::Request<super::GetJobRequest>,
        ) -> std::result::Result<tonic::Response<super::GetJobResponse>, tonic::Status>;
        /// Delete a job
        async fn delete_job_alpha1(
            &self,
            request: tonic::Request<super::DeleteJobRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteJobResponse>,
            tonic::Status,
        >;
    }
    /// Dapr service provides APIs to user application to access Dapr building blocks.
    #[derive(Debug)]
    pub struct DaprServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> DaprServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for DaprServer<T>
    where
        T: Dapr,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/dapr.proto.runtime.v1.Dapr/InvokeService" => {
                    #[allow(non_camel_case_types)]
                    struct InvokeServiceSvc<T: Dapr>(pub Arc<T>);
                    impl<
                        T: Dapr,
                    > tonic::server::UnaryService<super::InvokeServiceRequest>
                    for InvokeServiceSvc<T> {
                        type Response = super::super::super::common::v1::InvokeResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::InvokeServiceRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::invoke_service(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = InvokeServiceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/GetState" => {
                    #[allow(non_camel_case_types)]
                    struct GetStateSvc<T: Dapr>(pub Arc<T>);
                    impl<T: Dapr> tonic::server::UnaryService<super::GetStateRequest>
                    for GetStateSvc<T> {
                        type Response = super::GetStateResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetStateRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::get_state(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetStateSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/GetBulkState" => {
                    #[allow(non_camel_case_types)]
                    struct GetBulkStateSvc<T: Dapr>(pub Arc<T>);
                    impl<T: Dapr> tonic::server::UnaryService<super::GetBulkStateRequest>
                    for GetBulkStateSvc<T> {
                        type Response = super::GetBulkStateResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetBulkStateRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::get_bulk_state(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetBulkStateSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/SaveState" => {
                    #[allow(non_camel_case_types)]
                    struct SaveStateSvc<T: Dapr>(pub Arc<T>);
                    impl<T: Dapr> tonic::server::UnaryService<super::SaveStateRequest>
                    for SaveStateSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SaveStateRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::save_state(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SaveStateSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/QueryStateAlpha1" => {
                    #[allow(non_camel_case_types)]
                    struct QueryStateAlpha1Svc<T: Dapr>(pub Arc<T>);
                    impl<T: Dapr> tonic::server::UnaryService<super::QueryStateRequest>
                    for QueryStateAlpha1Svc<T> {
                        type Response = super::QueryStateResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueryStateRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::query_state_alpha1(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = QueryStateAlpha1Svc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/DeleteState" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteStateSvc<T: Dapr>(pub Arc<T>);
                    impl<T: Dapr> tonic::server::UnaryService<super::DeleteStateRequest>
                    for DeleteStateSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteStateRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::delete_state(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteStateSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/DeleteBulkState" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteBulkStateSvc<T: Dapr>(pub Arc<T>);
                    impl<
                        T: Dapr,
                    > tonic::server::UnaryService<super::DeleteBulkStateRequest>
                    for DeleteBulkStateSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteBulkStateRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::delete_bulk_state(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteBulkStateSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/ExecuteStateTransaction" => {
                    #[allow(non_camel_case_types)]
                    struct ExecuteStateTransactionSvc<T: Dapr>(pub Arc<T>);
                    impl<
                        T: Dapr,
                    > tonic::server::UnaryService<super::ExecuteStateTransactionRequest>
                    for ExecuteStateTransactionSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::ExecuteStateTransactionRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::execute_state_transaction(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ExecuteStateTransactionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/PublishEvent" => {
                    #[allow(non_camel_case_types)]
                    struct PublishEventSvc<T: Dapr>(pub Arc<T>);
                    impl<T: Dapr> tonic::server::UnaryService<super::PublishEventRequest>
                    for PublishEventSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PublishEventRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::publish_event(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PublishEventSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/BulkPublishEventAlpha1" => {
                    #[allow(non_camel_case_types)]
                    struct BulkPublishEventAlpha1Svc<T: Dapr>(pub Arc<T>);
                    impl<T: Dapr> tonic::server::UnaryService<super::BulkPublishRequest>
                    for BulkPublishEventAlpha1Svc<T> {
                        type Response = super::BulkPublishResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::BulkPublishRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::bulk_publish_event_alpha1(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = BulkPublishEventAlpha1Svc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/SubscribeTopicEventsAlpha1" => {
                    #[allow(non_camel_case_types)]
                    struct SubscribeTopicEventsAlpha1Svc<T: Dapr>(pub Arc<T>);
                    impl<
                        T: Dapr,
                    > tonic::server::StreamingService<
                        super::SubscribeTopicEventsRequestAlpha1,
                    > for SubscribeTopicEventsAlpha1Svc<T> {
                        type Response = super::SubscribeTopicEventsResponseAlpha1;
                        type ResponseStream = T::SubscribeTopicEventsAlpha1Stream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                tonic::Streaming<super::SubscribeTopicEventsRequestAlpha1>,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::subscribe_topic_events_alpha1(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SubscribeTopicEventsAlpha1Svc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/InvokeBinding" => {
                    #[allow(non_camel_case_types)]
                    struct InvokeBindingSvc<T: Dapr>(pub Arc<T>);
                    impl<
                        T: Dapr,
                    > tonic::server::UnaryService<super::InvokeBindingRequest>
                    for InvokeBindingSvc<T> {
                        type Response = super::InvokeBindingResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::InvokeBindingRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::invoke_binding(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = InvokeBindingSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/GetSecret" => {
                    #[allow(non_camel_case_types)]
                    struct GetSecretSvc<T: Dapr>(pub Arc<T>);
                    impl<T: Dapr> tonic::server::UnaryService<super::GetSecretRequest>
                    for GetSecretSvc<T> {
                        type Response = super::GetSecretResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetSecretRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::get_secret(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetSecretSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/GetBulkSecret" => {
                    #[allow(non_camel_case_types)]
                    struct GetBulkSecretSvc<T: Dapr>(pub Arc<T>);
                    impl<
                        T: Dapr,
                    > tonic::server::UnaryService<super::GetBulkSecretRequest>
                    for GetBulkSecretSvc<T> {
                        type Response = super::GetBulkSecretResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetBulkSecretRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::get_bulk_secret(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetBulkSecretSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/RegisterActorTimer" => {
                    #[allow(non_camel_case_types)]
                    struct RegisterActorTimerSvc<T: Dapr>(pub Arc<T>);
                    impl<
                        T: Dapr,
                    > tonic::server::UnaryService<super::RegisterActorTimerRequest>
                    for RegisterActorTimerSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RegisterActorTimerRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::register_actor_timer(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RegisterActorTimerSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/UnregisterActorTimer" => {
                    #[allow(non_camel_case_types)]
                    struct UnregisterActorTimerSvc<T: Dapr>(pub Arc<T>);
                    impl<
                        T: Dapr,
                    > tonic::server::UnaryService<super::UnregisterActorTimerRequest>
                    for UnregisterActorTimerSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UnregisterActorTimerRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::unregister_actor_timer(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UnregisterActorTimerSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/RegisterActorReminder" => {
                    #[allow(non_camel_case_types)]
                    struct RegisterActorReminderSvc<T: Dapr>(pub Arc<T>);
                    impl<
                        T: Dapr,
                    > tonic::server::UnaryService<super::RegisterActorReminderRequest>
                    for RegisterActorReminderSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RegisterActorReminderRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::register_actor_reminder(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RegisterActorReminderSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/UnregisterActorReminder" => {
                    #[allow(non_camel_case_types)]
                    struct UnregisterActorReminderSvc<T: Dapr>(pub Arc<T>);
                    impl<
                        T: Dapr,
                    > tonic::server::UnaryService<super::UnregisterActorReminderRequest>
                    for UnregisterActorReminderSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::UnregisterActorReminderRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::unregister_actor_reminder(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UnregisterActorReminderSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/GetActorState" => {
                    #[allow(non_camel_case_types)]
                    struct GetActorStateSvc<T: Dapr>(pub Arc<T>);
                    impl<
                        T: Dapr,
                    > tonic::server::UnaryService<super::GetActorStateRequest>
                    for GetActorStateSvc<T> {
                        type Response = super::GetActorStateResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetActorStateRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::get_actor_state(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetActorStateSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/ExecuteActorStateTransaction" => {
                    #[allow(non_camel_case_types)]
                    struct ExecuteActorStateTransactionSvc<T: Dapr>(pub Arc<T>);
                    impl<
                        T: Dapr,
                    > tonic::server::UnaryService<
                        super::ExecuteActorStateTransactionRequest,
                    > for ExecuteActorStateTransactionSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::ExecuteActorStateTransactionRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::execute_actor_state_transaction(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ExecuteActorStateTransactionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/InvokeActor" => {
                    #[allow(non_camel_case_types)]
                    struct InvokeActorSvc<T: Dapr>(pub Arc<T>);
                    impl<T: Dapr> tonic::server::UnaryService<super::InvokeActorRequest>
                    for InvokeActorSvc<T> {
                        type Response = super::InvokeActorResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::InvokeActorRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::invoke_actor(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = InvokeActorSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/GetConfigurationAlpha1" => {
                    #[allow(non_camel_case_types)]
                    struct GetConfigurationAlpha1Svc<T: Dapr>(pub Arc<T>);
                    impl<
                        T: Dapr,
                    > tonic::server::UnaryService<super::GetConfigurationRequest>
                    for GetConfigurationAlpha1Svc<T> {
                        type Response = super::GetConfigurationResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetConfigurationRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::get_configuration_alpha1(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetConfigurationAlpha1Svc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/GetConfiguration" => {
                    #[allow(non_camel_case_types)]
                    struct GetConfigurationSvc<T: Dapr>(pub Arc<T>);
                    impl<
                        T: Dapr,
                    > tonic::server::UnaryService<super::GetConfigurationRequest>
                    for GetConfigurationSvc<T> {
                        type Response = super::GetConfigurationResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetConfigurationRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::get_configuration(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetConfigurationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/SubscribeConfigurationAlpha1" => {
                    #[allow(non_camel_case_types)]
                    struct SubscribeConfigurationAlpha1Svc<T: Dapr>(pub Arc<T>);
                    impl<
                        T: Dapr,
                    > tonic::server::ServerStreamingService<
                        super::SubscribeConfigurationRequest,
                    > for SubscribeConfigurationAlpha1Svc<T> {
                        type Response = super::SubscribeConfigurationResponse;
                        type ResponseStream = T::SubscribeConfigurationAlpha1Stream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SubscribeConfigurationRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::subscribe_configuration_alpha1(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SubscribeConfigurationAlpha1Svc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/SubscribeConfiguration" => {
                    #[allow(non_camel_case_types)]
                    struct SubscribeConfigurationSvc<T: Dapr>(pub Arc<T>);
                    impl<
                        T: Dapr,
                    > tonic::server::ServerStreamingService<
                        super::SubscribeConfigurationRequest,
                    > for SubscribeConfigurationSvc<T> {
                        type Response = super::SubscribeConfigurationResponse;
                        type ResponseStream = T::SubscribeConfigurationStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SubscribeConfigurationRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::subscribe_configuration(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SubscribeConfigurationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/UnsubscribeConfigurationAlpha1" => {
                    #[allow(non_camel_case_types)]
                    struct UnsubscribeConfigurationAlpha1Svc<T: Dapr>(pub Arc<T>);
                    impl<
                        T: Dapr,
                    > tonic::server::UnaryService<super::UnsubscribeConfigurationRequest>
                    for UnsubscribeConfigurationAlpha1Svc<T> {
                        type Response = super::UnsubscribeConfigurationResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::UnsubscribeConfigurationRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::unsubscribe_configuration_alpha1(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UnsubscribeConfigurationAlpha1Svc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/UnsubscribeConfiguration" => {
                    #[allow(non_camel_case_types)]
                    struct UnsubscribeConfigurationSvc<T: Dapr>(pub Arc<T>);
                    impl<
                        T: Dapr,
                    > tonic::server::UnaryService<super::UnsubscribeConfigurationRequest>
                    for UnsubscribeConfigurationSvc<T> {
                        type Response = super::UnsubscribeConfigurationResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::UnsubscribeConfigurationRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::unsubscribe_configuration(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UnsubscribeConfigurationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/TryLockAlpha1" => {
                    #[allow(non_camel_case_types)]
                    struct TryLockAlpha1Svc<T: Dapr>(pub Arc<T>);
                    impl<T: Dapr> tonic::server::UnaryService<super::TryLockRequest>
                    for TryLockAlpha1Svc<T> {
                        type Response = super::TryLockResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::TryLockRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::try_lock_alpha1(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = TryLockAlpha1Svc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/UnlockAlpha1" => {
                    #[allow(non_camel_case_types)]
                    struct UnlockAlpha1Svc<T: Dapr>(pub Arc<T>);
                    impl<T: Dapr> tonic::server::UnaryService<super::UnlockRequest>
                    for UnlockAlpha1Svc<T> {
                        type Response = super::UnlockResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UnlockRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::unlock_alpha1(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UnlockAlpha1Svc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/EncryptAlpha1" => {
                    #[allow(non_camel_case_types)]
                    struct EncryptAlpha1Svc<T: Dapr>(pub Arc<T>);
                    impl<T: Dapr> tonic::server::StreamingService<super::EncryptRequest>
                    for EncryptAlpha1Svc<T> {
                        type Response = super::EncryptResponse;
                        type ResponseStream = T::EncryptAlpha1Stream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                tonic::Streaming<super::EncryptRequest>,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::encrypt_alpha1(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = EncryptAlpha1Svc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/DecryptAlpha1" => {
                    #[allow(non_camel_case_types)]
                    struct DecryptAlpha1Svc<T: Dapr>(pub Arc<T>);
                    impl<T: Dapr> tonic::server::StreamingService<super::DecryptRequest>
                    for DecryptAlpha1Svc<T> {
                        type Response = super::DecryptResponse;
                        type ResponseStream = T::DecryptAlpha1Stream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                tonic::Streaming<super::DecryptRequest>,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::decrypt_alpha1(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DecryptAlpha1Svc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/GetMetadata" => {
                    #[allow(non_camel_case_types)]
                    struct GetMetadataSvc<T: Dapr>(pub Arc<T>);
                    impl<T: Dapr> tonic::server::UnaryService<super::GetMetadataRequest>
                    for GetMetadataSvc<T> {
                        type Response = super::GetMetadataResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetMetadataRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::get_metadata(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetMetadataSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/SetMetadata" => {
                    #[allow(non_camel_case_types)]
                    struct SetMetadataSvc<T: Dapr>(pub Arc<T>);
                    impl<T: Dapr> tonic::server::UnaryService<super::SetMetadataRequest>
                    for SetMetadataSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SetMetadataRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::set_metadata(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetMetadataSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/SubtleGetKeyAlpha1" => {
                    #[allow(non_camel_case_types)]
                    struct SubtleGetKeyAlpha1Svc<T: Dapr>(pub Arc<T>);
                    impl<T: Dapr> tonic::server::UnaryService<super::SubtleGetKeyRequest>
                    for SubtleGetKeyAlpha1Svc<T> {
                        type Response = super::SubtleGetKeyResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SubtleGetKeyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::subtle_get_key_alpha1(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SubtleGetKeyAlpha1Svc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/SubtleEncryptAlpha1" => {
                    #[allow(non_camel_case_types)]
                    struct SubtleEncryptAlpha1Svc<T: Dapr>(pub Arc<T>);
                    impl<
                        T: Dapr,
                    > tonic::server::UnaryService<super::SubtleEncryptRequest>
                    for SubtleEncryptAlpha1Svc<T> {
                        type Response = super::SubtleEncryptResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SubtleEncryptRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::subtle_encrypt_alpha1(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SubtleEncryptAlpha1Svc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/SubtleDecryptAlpha1" => {
                    #[allow(non_camel_case_types)]
                    struct SubtleDecryptAlpha1Svc<T: Dapr>(pub Arc<T>);
                    impl<
                        T: Dapr,
                    > tonic::server::UnaryService<super::SubtleDecryptRequest>
                    for SubtleDecryptAlpha1Svc<T> {
                        type Response = super::SubtleDecryptResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SubtleDecryptRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::subtle_decrypt_alpha1(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SubtleDecryptAlpha1Svc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/SubtleWrapKeyAlpha1" => {
                    #[allow(non_camel_case_types)]
                    struct SubtleWrapKeyAlpha1Svc<T: Dapr>(pub Arc<T>);
                    impl<
                        T: Dapr,
                    > tonic::server::UnaryService<super::SubtleWrapKeyRequest>
                    for SubtleWrapKeyAlpha1Svc<T> {
                        type Response = super::SubtleWrapKeyResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SubtleWrapKeyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::subtle_wrap_key_alpha1(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SubtleWrapKeyAlpha1Svc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/SubtleUnwrapKeyAlpha1" => {
                    #[allow(non_camel_case_types)]
                    struct SubtleUnwrapKeyAlpha1Svc<T: Dapr>(pub Arc<T>);
                    impl<
                        T: Dapr,
                    > tonic::server::UnaryService<super::SubtleUnwrapKeyRequest>
                    for SubtleUnwrapKeyAlpha1Svc<T> {
                        type Response = super::SubtleUnwrapKeyResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SubtleUnwrapKeyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::subtle_unwrap_key_alpha1(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SubtleUnwrapKeyAlpha1Svc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/SubtleSignAlpha1" => {
                    #[allow(non_camel_case_types)]
                    struct SubtleSignAlpha1Svc<T: Dapr>(pub Arc<T>);
                    impl<T: Dapr> tonic::server::UnaryService<super::SubtleSignRequest>
                    for SubtleSignAlpha1Svc<T> {
                        type Response = super::SubtleSignResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SubtleSignRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::subtle_sign_alpha1(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SubtleSignAlpha1Svc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/SubtleVerifyAlpha1" => {
                    #[allow(non_camel_case_types)]
                    struct SubtleVerifyAlpha1Svc<T: Dapr>(pub Arc<T>);
                    impl<T: Dapr> tonic::server::UnaryService<super::SubtleVerifyRequest>
                    for SubtleVerifyAlpha1Svc<T> {
                        type Response = super::SubtleVerifyResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SubtleVerifyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::subtle_verify_alpha1(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SubtleVerifyAlpha1Svc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/StartWorkflowAlpha1" => {
                    #[allow(non_camel_case_types)]
                    struct StartWorkflowAlpha1Svc<T: Dapr>(pub Arc<T>);
                    impl<
                        T: Dapr,
                    > tonic::server::UnaryService<super::StartWorkflowRequest>
                    for StartWorkflowAlpha1Svc<T> {
                        type Response = super::StartWorkflowResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StartWorkflowRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::start_workflow_alpha1(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = StartWorkflowAlpha1Svc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/GetWorkflowAlpha1" => {
                    #[allow(non_camel_case_types)]
                    struct GetWorkflowAlpha1Svc<T: Dapr>(pub Arc<T>);
                    impl<T: Dapr> tonic::server::UnaryService<super::GetWorkflowRequest>
                    for GetWorkflowAlpha1Svc<T> {
                        type Response = super::GetWorkflowResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetWorkflowRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::get_workflow_alpha1(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetWorkflowAlpha1Svc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/PurgeWorkflowAlpha1" => {
                    #[allow(non_camel_case_types)]
                    struct PurgeWorkflowAlpha1Svc<T: Dapr>(pub Arc<T>);
                    impl<
                        T: Dapr,
                    > tonic::server::UnaryService<super::PurgeWorkflowRequest>
                    for PurgeWorkflowAlpha1Svc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PurgeWorkflowRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::purge_workflow_alpha1(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PurgeWorkflowAlpha1Svc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/TerminateWorkflowAlpha1" => {
                    #[allow(non_camel_case_types)]
                    struct TerminateWorkflowAlpha1Svc<T: Dapr>(pub Arc<T>);
                    impl<
                        T: Dapr,
                    > tonic::server::UnaryService<super::TerminateWorkflowRequest>
                    for TerminateWorkflowAlpha1Svc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::TerminateWorkflowRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::terminate_workflow_alpha1(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = TerminateWorkflowAlpha1Svc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/PauseWorkflowAlpha1" => {
                    #[allow(non_camel_case_types)]
                    struct PauseWorkflowAlpha1Svc<T: Dapr>(pub Arc<T>);
                    impl<
                        T: Dapr,
                    > tonic::server::UnaryService<super::PauseWorkflowRequest>
                    for PauseWorkflowAlpha1Svc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PauseWorkflowRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::pause_workflow_alpha1(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PauseWorkflowAlpha1Svc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/ResumeWorkflowAlpha1" => {
                    #[allow(non_camel_case_types)]
                    struct ResumeWorkflowAlpha1Svc<T: Dapr>(pub Arc<T>);
                    impl<
                        T: Dapr,
                    > tonic::server::UnaryService<super::ResumeWorkflowRequest>
                    for ResumeWorkflowAlpha1Svc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ResumeWorkflowRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::resume_workflow_alpha1(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ResumeWorkflowAlpha1Svc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/RaiseEventWorkflowAlpha1" => {
                    #[allow(non_camel_case_types)]
                    struct RaiseEventWorkflowAlpha1Svc<T: Dapr>(pub Arc<T>);
                    impl<
                        T: Dapr,
                    > tonic::server::UnaryService<super::RaiseEventWorkflowRequest>
                    for RaiseEventWorkflowAlpha1Svc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RaiseEventWorkflowRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::raise_event_workflow_alpha1(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RaiseEventWorkflowAlpha1Svc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/StartWorkflowBeta1" => {
                    #[allow(non_camel_case_types)]
                    struct StartWorkflowBeta1Svc<T: Dapr>(pub Arc<T>);
                    impl<
                        T: Dapr,
                    > tonic::server::UnaryService<super::StartWorkflowRequest>
                    for StartWorkflowBeta1Svc<T> {
                        type Response = super::StartWorkflowResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StartWorkflowRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::start_workflow_beta1(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = StartWorkflowBeta1Svc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/GetWorkflowBeta1" => {
                    #[allow(non_camel_case_types)]
                    struct GetWorkflowBeta1Svc<T: Dapr>(pub Arc<T>);
                    impl<T: Dapr> tonic::server::UnaryService<super::GetWorkflowRequest>
                    for GetWorkflowBeta1Svc<T> {
                        type Response = super::GetWorkflowResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetWorkflowRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::get_workflow_beta1(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetWorkflowBeta1Svc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/PurgeWorkflowBeta1" => {
                    #[allow(non_camel_case_types)]
                    struct PurgeWorkflowBeta1Svc<T: Dapr>(pub Arc<T>);
                    impl<
                        T: Dapr,
                    > tonic::server::UnaryService<super::PurgeWorkflowRequest>
                    for PurgeWorkflowBeta1Svc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PurgeWorkflowRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::purge_workflow_beta1(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PurgeWorkflowBeta1Svc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/TerminateWorkflowBeta1" => {
                    #[allow(non_camel_case_types)]
                    struct TerminateWorkflowBeta1Svc<T: Dapr>(pub Arc<T>);
                    impl<
                        T: Dapr,
                    > tonic::server::UnaryService<super::TerminateWorkflowRequest>
                    for TerminateWorkflowBeta1Svc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::TerminateWorkflowRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::terminate_workflow_beta1(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = TerminateWorkflowBeta1Svc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/PauseWorkflowBeta1" => {
                    #[allow(non_camel_case_types)]
                    struct PauseWorkflowBeta1Svc<T: Dapr>(pub Arc<T>);
                    impl<
                        T: Dapr,
                    > tonic::server::UnaryService<super::PauseWorkflowRequest>
                    for PauseWorkflowBeta1Svc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PauseWorkflowRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::pause_workflow_beta1(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PauseWorkflowBeta1Svc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/ResumeWorkflowBeta1" => {
                    #[allow(non_camel_case_types)]
                    struct ResumeWorkflowBeta1Svc<T: Dapr>(pub Arc<T>);
                    impl<
                        T: Dapr,
                    > tonic::server::UnaryService<super::ResumeWorkflowRequest>
                    for ResumeWorkflowBeta1Svc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ResumeWorkflowRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::resume_workflow_beta1(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ResumeWorkflowBeta1Svc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/RaiseEventWorkflowBeta1" => {
                    #[allow(non_camel_case_types)]
                    struct RaiseEventWorkflowBeta1Svc<T: Dapr>(pub Arc<T>);
                    impl<
                        T: Dapr,
                    > tonic::server::UnaryService<super::RaiseEventWorkflowRequest>
                    for RaiseEventWorkflowBeta1Svc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RaiseEventWorkflowRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::raise_event_workflow_beta1(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RaiseEventWorkflowBeta1Svc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/Shutdown" => {
                    #[allow(non_camel_case_types)]
                    struct ShutdownSvc<T: Dapr>(pub Arc<T>);
                    impl<T: Dapr> tonic::server::UnaryService<super::ShutdownRequest>
                    for ShutdownSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ShutdownRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::shutdown(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ShutdownSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/ScheduleJobAlpha1" => {
                    #[allow(non_camel_case_types)]
                    struct ScheduleJobAlpha1Svc<T: Dapr>(pub Arc<T>);
                    impl<T: Dapr> tonic::server::UnaryService<super::ScheduleJobRequest>
                    for ScheduleJobAlpha1Svc<T> {
                        type Response = super::ScheduleJobResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ScheduleJobRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::schedule_job_alpha1(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ScheduleJobAlpha1Svc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/GetJobAlpha1" => {
                    #[allow(non_camel_case_types)]
                    struct GetJobAlpha1Svc<T: Dapr>(pub Arc<T>);
                    impl<T: Dapr> tonic::server::UnaryService<super::GetJobRequest>
                    for GetJobAlpha1Svc<T> {
                        type Response = super::GetJobResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetJobRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::get_job_alpha1(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetJobAlpha1Svc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/dapr.proto.runtime.v1.Dapr/DeleteJobAlpha1" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteJobAlpha1Svc<T: Dapr>(pub Arc<T>);
                    impl<T: Dapr> tonic::server::UnaryService<super::DeleteJobRequest>
                    for DeleteJobAlpha1Svc<T> {
                        type Response = super::DeleteJobResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteJobRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Dapr>::delete_job_alpha1(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteJobAlpha1Svc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for DaprServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "dapr.proto.runtime.v1.Dapr";
    impl<T> tonic::server::NamedService for DaprServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
